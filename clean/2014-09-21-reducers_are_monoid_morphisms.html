<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2014-09-21-reducers_are_monoid_morphisms</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="mlisp.css" />
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <base href="https://kaygun.github.io/">
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="reducers-are-monoid-morphisms">Reducers are Monoid
Morphisms</h1>
<p><a href="2014-09-07-cons_is_your_friend.html">Last week</a> I wrote
about <a href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Guy
Steele’s</a> talk <a href="http://vimeo.com/6624203">“<code>foldl</code>
and <code>foldr</code> are considered slightly harmful”</a> which I
first heard from <a href="http://vimeo.com/45561411">Rich Hickey</a>.
Steele’s conclusion was that for truly parallel data structures and
algorithms <code>cons</code> was not a good basis. I disagree, and still
think that one can use <code>cons</code> in an effective way to do what
Steele wants to do.</p>
<p>Yesterday, I was watching Rich Hickey’s <a
href="http://youtu.be/6mTbuzafcII">talk on Transducers</a> he gave at <a
href="http://thestrangeloop.com/">StrangeLoop</a>. This again reminded
of me his <a href="http://vimeo.com/45561411">talk on Reducers</a>.
Being a mathematician, and not a programmer proper, I have to make sense
of things in my own way. Writing is one of them, and I hope this might
be of interest for some.</p>
<h2 id="reducing-associative-containers">Reducing associative
containers</h2>
<p>An <em>associative container</em> is a linearly ordered collection of
objects of a certain type, or mixed types, such as a sequence or a
linked list or a vector. A <em>reducing function</em> is a unital
associative binary operation. That is all we need to implement a serial
fold:</p>
<pre><code>(defun serial-fold (sequence reducer &amp;optional accumulator)
   (cond ((null sequence) accumulator)
         ((atom sequence) (funcall reducer accumulator sequence))
         (t (serial-fold (cdr sequence) 
                          reducer 
                          (funcall reducer accumulator (car sequence))))))

SERIAL-FOLD

(serial-fold &#39;(9 8 7 6 5 4 3 2 1) #&#39;+ 0)

45

(serial-fold &#39;(9 8 7 6 5 4 3 2 1) (lambda (x y) (cons y x)) nil)

(1 2 3 4 5 6 7 8 9)</code></pre>
<p>I cheated in the second example: notice that we don’t need
associativity because we processed the list sequentially and in order
both in time and in space. If we were to process the container in
parallel by splitting into sublists and put them together using the same
reducer function, then even though the first example would still return
45, the second example could return something else. This is because the
<code>cons</code> operator is neither unital nor associative.</p>
<p>In any case, for a mathematician, someone whose mind is bent towards
making abstractions, an associative container can be thought as an
element of a free monoid generated by a type of elements, or mixed types
of elements. I am not the only, or not even the first, person making
this connection. See for example Dan Piponi’s <a
href="http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html">post
on monoids in Haskell</a>, or better yet <a
href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Steele’s
talk</a>.</p>
<h2 id="truly-parallel-data-structures-and-map-reduce">Truly parallel
data structures and <code>map-reduce</code></h2>
<p>As I said earlier, I came to Steele’s <a
href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">talk on
<code>fold</code></a> through Hickey’s <a
href="http://vimeo.com/45561411">talk on Reducers</a>. Hickey has been
thinking about concurrent programming for a long time, and you can see
the effects of this in the solid design of <a
href="http://www.clojure.org">Clojure</a>. The problem he was
elaborating on his talk on <a
href="http://vimeo.com/45561411">Reducers</a> was concurrent folding on
large collections. Steele, Hickey and others before them, observed that
a well-designed <code>map-reduce</code> does actually solve that
problem. By the way, the earliest version of the argument, that fold is
universal in some sense, I could find was by Sheard and Feragas, “A Fold
for all Seasons.” I highly recommend it.</p>
<p>In any case, Hickey and Steele got it right: one has to use a version
of <code>map-reduce</code> that Steele describes instead of a sequential
<code>fold</code> for a concurrent processing of data collected in a
container.</p>
<p>Here is a simplified version of the implementation I gave for
<code>map-reduce</code> <a
href="2014-09-07-cons_is_your_friend.html">last week</a></p>
<pre><code>(defun map-reduce (tree reducer mapper)
   (if (atom tree) 
      (funcall mapper tree)
      (funcall reducer (map-reduce (car tree) reducer mapper)
                       (map-reduce (cdr tree) reducer mapper))))

MAP-REDUCE</code></pre>
<p>In this version, <code>map-reduce</code> doesn’t care how deep the
call is in the tree and both <code>reducer</code> and
<code>mapper</code> work the same way regardless of the depth. Here, I
also make the assumption that if you call the <code>mapper</code>
function with <code>nil</code> it must return the unit element for the
<code>reducer</code> function.</p>
<pre><code>(map-reduce 
   &#39;((1 . 2) ((3 . 4) . 5) . 6)
   (lambda (&amp;optional x y)
      (cond ((null y) x)
            ((null x) y)
            (t (cons x y))))
   (lambda (x)
      (if (not (null x))
          (* x x))))

((1 . 4) ((9 . 16) . 25) . 36)</code></pre>
<p>Notice that I used a modified version of <code>cons</code> as the
reducer essentially by making this version unital with <code>nil</code>
being the unit, i.e. if you <code>ucons</code> any object with nil you
get the same object back. I am going to need this function quite a
bit.</p>
<pre><code>(defun ucons (&amp;rest x) 
   (cond ((null x) nil)
         ((null (cadr x)) (car x))
         ((null (car x)) (cadr x))
         (t (cons (car x) (cadr x)))))

UCONS</code></pre>
<h2 id="reducers-are-morphisms-of-monoids">Reducers are morphisms of
monoids</h2>
<p>Following Antoine de Saint Exupery’s dictum that “perfection is
reached not when there is nothing left to add, but when there is nothing
left to take away,” before we go any further, let me simplify the
<code>map-reduce</code> function a bit more:</p>
<pre><code>(defun map-reduce (tree reducer)
   (if (atom tree) 
      (funcall reducer tree)
      (funcall reducer (map-reduce (car tree) reducer)
                       (map-reduce (cdr tree) reducer))))

MAP-REDUCE</code></pre>
<p>In this version we make the following assumptions:</p>
<ol type="1">
<li><p>If we call <code>reducer</code> on an empty container we get the
unit for the <code>reducer</code> function. Remember
<code>reducer</code> is a unital associative operation.</p></li>
<li><p>If we call <code>reducer</code> on a single object, we must get a
mapped version of the object.</p></li>
<li><p>If we call <code>reducer</code> on two objects, it does
<em>combining</em> using a unital associative operation.</p></li>
</ol>
<p>A mathematician would say, what I described above is a monoid
morphism from a free monoid (linked lists can be thought as elements of
a free monoid) to a another monoid. For example consider the
function</p>
<pre><code>(defun a-monoid-morphism (&amp;rest x)
   (cond ((null x) 0)                  
         ((null (cadr x)) (car x))     
         (t (+ (car x) (cadr x)))))

A-MONOID-MORPHISM</code></pre>
<p>This is a monoid morphism from the free monoid generated by number
objects where the monoid operation is concatenation, into the monoid of
natural numbers where the associative operation is <code>+</code> and
the unit is 0. Now, when we feed this function to
<code>map-reduce</code></p>
<pre><code>(map-reduce 
   &#39;(9 8 7 6 5 4 3 2 1)
   #&#39;a-monoid-morphism)

45</code></pre>
<p>Here the list <code>(9 8 7 6 5 4 3 2 1)</code> represents an element
in the free monoid generated by integers and the reducer sends this
element to the corresponding element in the monoid of natural
numbers.</p>
<p>As a matter of fact, any foldable container, not just linked lists
will do. These also include non-unital, even nonassociative containers.
A non-unital and nonassociative binary operation is called a <a
href="http://en.wikipedia.org/wiki/Magma_%28algebra%29">magma</a>. We
usually call containers with this shape as <a
href="http://en.wikipedia.org/wiki/Binary_tree">binary trees</a>. The
<code>map-reduce</code> I implemented above works with them too.</p>
<p>I need a random tree for testing purposes.</p>
<pre><code>just-a-tree

(((5 . 1) ((3 . 5) . 4) 10 . 0) (9 1 1 . 3) . 7)

(map-reduce just-a-tree #&#39;a-monoid-morphism)

49</code></pre>
<p>Here is a proper morphism of magmas:</p>
<pre><code>(defun a-magma-morphism (&amp;rest x)
   (labels ((mapper (u) (if (listp u) u (* u u))))
      (if (null (cadr x)) 
         (mapper (car x))
         (ucons (car x) (cadr x)))))

A-MAGMA-MORPHISM

(map-reduce just-a-tree #&#39;a-magma-morphism)

(((25 . 1) ((9 . 25) . 16) 100 . 0) (81 1 1 . 9) . 49)</code></pre>
<p>Here we have a morphism of magmas from the free magma generated by
integers into the same magma where we send each generator x to
x<sup>2</sup>.</p>
<h2 id="using-intermediate-collections-vs-composition">Using
intermediate collections vs composition</h2>
<p>Consider the following two morphisms of magmas</p>
<pre><code>(defun m-reduce (oper)
   (lambda (&amp;rest x)
      (let ((unit (funcall oper)))
         (cond ((null x) unit)
               ((null (cadr x)) (if (car x) (funcall oper (car x)) unit))
               ((null (car x)) (if (cadr x) (funcall oper (cadr x)) unit))
               (t (funcall oper (car x) (cadr x)))))))

M-REDUCE

(map-reduce just-a-tree (m-reduce #&#39;+))

49</code></pre>
<p>and</p>
<pre><code>(defun m-map (f)
   (lambda (&amp;rest x)
      (if (cadr x)
         (ucons (car x) (cadr x))
         (if (listp (car x)) (car x) (funcall f (car x))))))

M-MAP

(map-reduce just-a-tree (m-map (lambda (x) (* x x))))

(((25 . 1) ((9 . 25) . 16) 100 . 0) (81 1 1 . 9) . 49)</code></pre>
<p>We are going to use the first to convert binary operators into magma
morphisms while second is for unary operators otherwise known as
ordinary functions. Notice that <code>m-map</code> begets a filtering
function if we pass the following</p>
<pre><code>(defun collect-if (pred)
   (lambda (x) 
      (cond ((listp x) x)
            ((funcall pred x) x)
            (t nil))))

COLLECT-IF

(map-reduce 
   just-a-tree
   (m-map (collect-if #&#39;oddp)))

(((5 . 1) 3 . 5) (9 1 1 . 3) . 7)</code></pre>
<p>The main problem occurs when we want to compose these operators. Even
after this conceptual simplification composition is still not efficient,
because we still have to create unnecessary intermediate collections
when we compose</p>
<pre><code>(map-reduce 
   (map-reduce 
      just-a-tree
      (m-map (collect-if #&#39;oddp)))
   (m-reduce #&#39;+))

35</code></pre>
<p>because we apply the filter first and we create a temporary
collection, and then apply a reduce operation adding the resulting
numbers. In the language of monoids, we perform the calculation <span
class="math display">\[ f(g(a\cdot b)) =
f(g(a)\cdot g(b)) = f(g(a))\cdot f(g(b)) \]</span> However, composition
of two monoid or magma morphisms is another monoid or magma morphism.
Hence we can skip the middle step.</p>
<p>I need a composition operator for monoid morphisms:</p>
<pre><code>(defun m-compose (f &amp;rest g)
   (if g
      (lambda (&amp;rest x)
         (cond ((null x) (funcall f))
               ((null (cadr x)) (funcall f (funcall (apply #&#39;m-compose g) (car x))))
               (t (funcall f (car x) (cadr x)))))
      f))

M-COMPOSE</code></pre>
<p>Let me test this:</p>
<pre><code>(map-reduce 
   just-a-tree
   (m-compose 
      (m-reduce #&#39;+)
      (m-map (lambda (x) (* x x)))
      (m-map (collect-if (lambda (x) (not (zerop x)))))))

317</code></pre>
<h2 id="an-analysis">An analysis</h2>
<p>I had two versions of the same workload on a large random binary tree
with approximately 10 million leaves:</p>
<pre><code>(map-reduce
   (map-reduce
      (map-reduce 
         large-tree
         (m-map (collect-if #&#39;evenp)))
      (m-map (lambda (x) (* x x))))
   (m-reduce #&#39;+))</code></pre>
<p>and</p>
<pre><code>(map-reduce
   large-tree
   (m-compose
      (m-reduce #&#39;+)
      (m-map (lambda (x) (* x x)))
      (m-map (collect-if #&#39;evenp))))</code></pre>
<p>I ran the code 5 times each. The averages are as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><em>Lisp</em></th>
<th style="text-align: right;"><em>Time</em> (sec)</th>
<th style="text-align: right;"><em>Memory</em> (1e9 B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SBCL</td>
<td style="text-align: right;">3.1 vs 2.3</td>
<td style="text-align: right;">0.9 vs 0.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">CCL</td>
<td style="text-align: right;">6.4 vs 8.2</td>
<td style="text-align: right;">0.8 vs 1.4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ECL</td>
<td style="text-align: right;">44.3 vs 32.9</td>
<td style="text-align: right;">3.4 vs 4.1</td>
</tr>
</tbody>
</table>
<p>I can’t see a drastic difference neither in running time or memory
allocation for <a href="http://www.sbcl.org/">SBCL</a> or <a
href="http://ccl.clozure.com/">ECL</a>, but <a
href="http://ecls.sourceforge.net/">CCL</a> does something wierd. Then
again, I am not a professional coder. There might be some tricks to coax
better performance out of the composition as opposed to using
intermediate collections. I’ll have to implement this in another
language to compare performances.</p>
<div id="footer">
<p><span id="timestamp">September 21st, 2014 5:07pm</span></p>
</div>
</body>
</html>
