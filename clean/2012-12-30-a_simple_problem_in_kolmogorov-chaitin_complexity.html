<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2012-12-30-a_simple_problem_in_kolmogorov-chaitin_complexity</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <html>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <base href="https://kaygun.github.io/">
  <link rel="stylesheet" type="text/css" href="style.css">


  <head>
  <title>The Kitchen Sink and Other Oddities</title>
  </head>

  <body>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ]
    }
  });
  </script>

  <div class="header">
  <h1><a href="https://kaygun.github.io">The Kitchen Sink and Other Oddities</a></h1>
  <p><a href="https://web.itu.edu.tr/kaygun">Atabey Kaygun</a></p>
  </div>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>A Simple Problem in Kolmogorov-Chaitin Complexity</p>
<h1 id="a-simple-problem-in-kolmogorov-chaitin-complexity">A simple
problem in Kolmogorov-Chaitin complexity</h1>
<p>This post is inspired by two old posts (<a
href="http://scientopia.org/blogs/goodmath/2006/06/24/an-introduction-to-information-theory-updated-from-blogspot/">this</a>
and <a
href="http://scientopia.org/blogs/goodmath/2009/09/21/information-vs-meaning/">that</a>)
on <a href="http://scientopia.org/blogs/goodmath">Good Math, Bad
Math</a> by <a href="https://twitter.com/MarkCC">Mark Chu-Carroll</a>.
It is just that I am a mathematician, and I need to dot all the i’s and
cross all the t’s. Besides, I learn better when I write things.</p>
<h2 id="description-of-the-problem">Description of the problem</h2>
<p>Let <span class="math inline">𝒜</span> be a finite set (hereby called
<em>an alphabet</em>) and consider the set <span
class="math inline">𝒲</span> of all finite sequences of elements of
<span class="math inline">𝒜</span> (hereby called <em>words</em>). I
will use <span
class="math inline"><em>l</em><em>e</em><em>n</em>(<em>w</em>)</span> to
denote the length of a word <span
class="math inline"><em>w</em> ∈ 𝒲</span>.</p>
<p>I will call any partial function of the form <span
class="math inline"><em>P</em>: 𝒲 → 𝒲</span> as a <em>finite abstract
computer</em>, and I will call the domain <span
class="math inline">𝒟(<em>P</em>)</span> of a finite abstract computer
as <em>the set of all admissible programs in <span
class="math inline"><em>P</em></span></em>. In this context a word <span
class="math inline"><em>w</em> ∈ 𝒲</span> is computable via <span
class="math inline"><em>P</em></span> if <span
class="math inline"><em>w</em></span> is in the range of <span
class="math inline"><em>P</em></span>.</p>
<p>I will say that a finite abstract computer <span
class="math inline"><em>P</em></span> emulates another finite abstract
computer <span class="math inline"><em>Q</em></span> if there is a fixed
admissible program <span
class="math inline"><em>w</em><sub><em>Q</em></sub></span> in <span
class="math inline"><em>P</em></span> such that for every admissible
program <span class="math inline"><em>a</em></span> in <span
class="math inline"><em>Q</em></span> the word <span
class="math inline"><em>w</em><sub><em>Q</em></sub><em>a</em></span> is
an admissible program in <span class="math inline"><em>P</em></span> and
we get <span
class="math display"><em>Q</em>(<em>a</em>) = <em>P</em>(<em>w</em><sub><em>Q</em></sub><em>a</em>)</span>
Here the concatenation of word <span
class="math inline"><em>w</em><sub><em>Q</em></sub></span> and <span
class="math inline"><em>a</em></span> is denoted by <span
class="math inline"><em>w</em><sub><em>Q</em></sub><em>a</em></span>.</p>
<p>The relative complexity of a word <span
class="math inline"><em>w</em> ∈ 𝒲</span> with respect to a finite
abstract computer <span class="math inline"><em>P</em></span> is defined
as <span
class="math display"><em>r</em><em>e</em><em>l</em>(<em>w</em>,<em>P</em>) := min {<em>l</em><em>e</em><em>n</em>(<em>v</em>)∥ <em>v</em> ∈ 𝒟(<em>P</em>)
and <em>P</em>(<em>v</em>) = <em>w</em>}</span> In other words, the
relative complexity of a word <span
class="math inline"><em>w</em></span> is the length of a shortest
admissible program in <span class="math inline"><em>P</em></span> which
generates <span class="math inline"><em>w</em></span>. If there is no
such word then <span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>w</em>,<em>P</em>)</span>
is defined to be <span class="math inline"> − 1</span>.</p>
<p>Now, take two finite abstract computers <span
class="math inline"><em>P</em></span> and <span
class="math inline"><em>Q</em></span>. Today, I would like to show that
if <span class="math inline"><em>P</em></span> and <span
class="math inline"><em>Q</em></span> emulate each other then there
exists a constant <span class="math inline"><em>c</em></span> such that
<span
class="math display">sup<sub><em>w</em> ∈ 𝒲</sub>∥<em>r</em><em>e</em><em>l</em>(<em>w</em>,<em>P</em>) − <em>r</em><em>e</em><em>l</em>(<em>w</em>,<em>Q</em>)∥ ≤ <em>c</em></span>
Now, if we define the distance between two finite abstract computers as
<span
class="math display"><em>d</em>(<em>P</em>,<em>Q</em>) = sup<sub><em>w</em> ∈ 𝒲</sub>∥<em>r</em><em>e</em><em>l</em>(<em>w</em>,<em>P</em>) − <em>r</em><em>e</em><em>l</em>(<em>w</em>,<em>Q</em>)∥</span>
we see that the statement above can be rephrased as follows:</p>
<blockquote>
<p>If <span class="math inline"><em>P</em></span> and <span
class="math inline"><em>Q</em></span> can emulate each other then the
distance <span
class="math inline"><em>d</em>(<em>P</em>,<em>Q</em>)</span> is
finite.</p>
</blockquote>
<p>Or, equivalently</p>
<blockquote>
<p>If the distance between two finite abstract computers is infinite
then one of these machines can not emulate the other.</p>
</blockquote>
<p>Though, I have to say that <span
class="math inline"><em>d</em></span> is <strong>not</strong> really a
distance in the sense of <a
href="http://mathworld.wolfram.com/MetricSpace.html">a metric space</a>
as I will mention at the end.</p>
<h2 id="a-proof-of-the-statement">A proof of the statement</h2>
<p>Assume <span class="math inline"><em>P</em></span> and <span
class="math inline"><em>Q</em></span> emulate each other, and
respectively let <span
class="math inline"><em>w</em><sub><em>Q</em></sub> ∈ 𝒟(<em>P</em>)</span>
and <span
class="math inline"><em>w</em><sub><em>P</em></sub> ∈ 𝒟(<em>Q</em>)</span>
be the admissible programs emulating <span
class="math inline"><em>Q</em></span> in <span
class="math inline"><em>P</em></span> and <span
class="math inline"><em>P</em></span> in <span
class="math inline"><em>Q</em></span>. Take a word <span
class="math inline"><em>v</em></span> which is computable via both <span
class="math inline"><em>P</em></span> and <span
class="math inline"><em>Q</em></span>. Then we can easily see that <span
class="math display"><em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>Q</em>) ≤ <em>l</em><em>e</em><em>n</em>(<em>w</em><sub><em>Q</em></sub>) + <em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>P</em>)  
and
  <em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>P</em>) ≤ <em>l</em><em>e</em><em>n</em>(<em>w</em><sub><em>P</em></sub>) + <em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>Q</em>)</span>
We get the inequality for <span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>Q</em>)</span>
because for any admissible program <span
class="math inline"><em>a</em></span> in <span
class="math inline"><em>P</em></span> with the property that <span
class="math inline"><em>v</em> = <em>P</em>(<em>a</em>)</span> (recall
that <span class="math inline"><em>v</em></span> is computable via <span
class="math inline"><em>P</em></span>) then we have <span
class="math inline"><em>v</em> = <em>Q</em>(<em>w</em><sub><em>P</em></sub><em>a</em>)</span>.
Conversely, since <span class="math inline"><em>v</em></span> is also
computable via <span class="math inline"><em>Q</em></span> we have the
similar inequality for <span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>P</em>)</span>.
Note that the inequalities hold even when <span
class="math inline"><em>v</em></span> is not computable via <span
class="math inline"><em>P</em></span> or via <span
class="math inline"><em>Q</em></span>. This easily leads to the
inequality <span
class="math display">∥<em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>P</em>) − <em>r</em><em>e</em><em>l</em>(<em>v</em>,<em>Q</em>)∥ ≤ max {<em>l</em><em>e</em><em>n</em>(<em>w</em><sub><em>P</em></sub>), <em>l</em><em>e</em><em>n</em>(<em>w</em><sub><em>Q</em></sub>)}</span>
for every <span class="math inline"><em>v</em> ∈ 𝒲</span>. Then we
preserve the inequality when we take the supremum over all <span
class="math inline"><em>w</em> ∈ 𝒲</span>.</p>
<h2 id="an-example">An example</h2>
<p>Let <span class="math inline">𝒜</span> contain a single letter <span
class="math inline">1</span>. So, the set of words in <span
class="math inline">𝒜</span> is naturally isomorphic to the set of
natural numbers. Now, I will define <span
class="math inline"><em>P</em>(<em>n</em>) = 2<em>n</em></span> and
<span class="math inline"><em>Q</em>(<em>n</em>) = 3<em>n</em></span>
for every <span class="math inline"><em>n</em> ∈ ℕ</span>. Notice that
<span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>n</em>,<em>P</em>) =  − 1</span>
if <span class="math inline"><em>n</em></span> is not even, and <span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>n</em>,<em>P</em>) = (<em>n</em>/2)</span>
when <span class="math inline"><em>n</em></span> is even. Similarly,
<span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>n</em>,<em>Q</em>) =  − 1</span>
when <span class="math inline"><em>n</em></span> is not divisible by 3,
and <span
class="math inline"><em>r</em><em>e</em><em>l</em>(<em>n</em>,<em>Q</em>) = (<em>n</em>/3)</span>
if <span class="math inline"><em>n</em></span> is divisible by 3. It is
easy to see that <span
class="math display">sup<sub><em>n</em> ∈ ℕ</sub>∥<em>r</em><em>e</em><em>l</em>(<em>n</em>,<em>P</em>) − <em>r</em><em>e</em><em>l</em>(<em>n</em>,<em>Q</em>)∥ = ∞</span>
Thus one of these finite abstract computers can not emulate the
other.</p>
<h2 id="a-counter-example-for-the-converse">A counter-example for the
converse</h2>
<p>Let <span class="math inline">𝒜</span> be as before and define <span
class="math inline"><em>P</em>(2<sup><em>n</em></sup>) = 1</span>
whenever <span class="math inline"><em>n</em></span> is a prime and
define <span
class="math inline"><em>Q</em>(3<sup><em>n</em></sup>) = 1</span>
whevever <span class="math inline"><em>n</em></span> is a prime.
Clearly, <span class="math inline"><em>P</em></span> and <span
class="math inline"><em>Q</em></span> are both partial functions. It
takes a little work (some number theory) to show that <span
class="math inline"><em>P</em></span> can not emulate <span
class="math inline"><em>Q</em></span> and vice versa. On the other and
<span class="math inline"><em>d</em>(<em>P</em>,<em>Q</em>) = 0</span>
which is finite. Also notice that the distance is 0 while <span
class="math inline"><em>P</em> ≠ <em>Q</em></span>. That is the function
<span class="math inline"><em>d</em></span> defined above is not really
a <a href="http://mathworld.wolfram.com/MetricSpace.html">metric</a> in
the strict mathematical sense.</p>
<div id="footer">
<p><span id="timestamp">December 30th, 2012 3:33pm</span></p>
</div>
</body>
</html>
