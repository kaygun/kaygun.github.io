<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2025-07-30-magmas-and-catamorphisms</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <html>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <base href="https://kaygun.github.io/">
  <link rel="stylesheet" type="text/css" href="style.css">


  <head>
  <title>The Kitchen Sink and Other Oddities</title>
  </head>

  <body>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ]
    }
  });
  </script>

  <div class="header">
  <h1><a href="https://kaygun.github.io">The Kitchen Sink and Other Oddities</a></h1>
  <p><a href="https://web.itu.edu.tr/kaygun">Atabey Kaygun</a></p>
  </div>

  <section>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<h1 id="a-strange-path-to-λ-magmas-and-catamorphisms">A Strange Path to
λ: Magmas and Catamorphisms</h1>
<h2 id="introduction">Introduction</h2>
<p>When Alonzo Church developed λ-calculus in the 1930s, it was a
theoretical construct designed to create a formal system for the
foundations of logic and mathematics that was simpler than Russell’s
type theory and Zermelo’s set theory. This calculus was type-free with
unrestricted quantification but without the law of excluded middle.
However, it failed miserably due to the <a
href="https://www.ams.org/journals/tran/1941-050-03/S0002-9947-1941-0005275-6/S0002-9947-1941-0005275-6.pdf">Kleene-Rosser
Paradox</a> which demonstrated that the calculus was inconsistent by
showing that both a proposition and its negation could be derived from
the same premises. The paradox exploited the calculus’ ability to encode
self-referential constructions, leading to a contradiction that
undermines the entire logical foundation. The calculus later evolved
into a symbolic computational framework based on substitution and
reduction, capable of performing any mechanical calculation. This is
also known as the <a
href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing
Thesis</a>.</p>
<h3 id="what-and-why">What and Why?</h3>
<p>Several decades ago, when I first encountered λ-calculus, I fell in
love with it—with its strangeness, simplicity, and elegance. Now that
pair programming with an LLM is an option, I thought I could implement
one. Actually, I created three: one <a
href="https://github.com/kaygun/lambda-mu">I spitballed in clojure</a>,
a <a href="https://github.com/kaygun/LambdaMu">straightforward
object-oriented implementation</a> in Scala using classes and class
inheritance, and <a href="https://github.com/kaygun/LambdaOnMagma">yet
another implementation</a> again in Scala, but based on some magma,
homomorphism, and catamorphism magic.</p>
<p>In this post, I am going to explain my view on the mathematical
foundations of the subject in order to explain some of the weird choices
I made in my last implementation in Scala.</p>
<p>I must clarify here: because the classical λ-calculus lacks double
negation elimination</p>
<p><span class="math display">\[ \frac{(P\implies \bot)\implies \bot}{P}
\]</span></p>
<p>(i.e., the Law of Excluded Middle), it models intuitionistic logic.
Extending it to support classical logic requires additional constructs,
such as control operators or continuation mechanisms, as found in the
λμ-calculus of Parigot. The clojure version, and the OO version I
implemented follows Parigot’s λμ-calculus, while the version I
implemented on magmas is the classical λ-calculus.</p>
<h2 id="mathematical-foundations">Mathematical Foundations</h2>
<p>To formally describe the syntactic structure of the untyped
λ-calculus, we must first distinguish between two levels of
representation: the <em>concrete syntax</em>, which consists of strings
generated by a formal grammar, and the <em>abstract syntax</em>, which
identifies the essential syntactic constructs free from superficial
details such as parentheses or concrete variable names. The formalism of
<em>formal languages</em> and <em>abstract syntax trees</em> provides a
precise framework for this distinction.</p>
<h3 id="the-definition">The Definition</h3>
<p>The λ-calculus consists of three syntactic forms:
<strong>variables</strong>, <strong>abstractions</strong>, and
<strong>applications</strong>.</p>
<p>A <strong>variable</strong> can be any symbol, typically denoted by
lowercase letters such as <span class="math inline">\(x\)</span> or
<span class="math inline">\(y\)</span>.</p>
<p>A <strong>function abstraction</strong> is written as <span
class="math inline">\(\lambda x.M\)</span> where <span
class="math inline">\(x\)</span> is the formal parameter and <span
class="math inline">\(M\)</span> is the function body. In this
expression, the variable <span class="math inline">\(x\)</span> is said
to be <em>bound</em>. Any variable that appears in an expression but is
not bound by a corresponding λ is called <em>free</em>.</p>
<p>A <strong>function application</strong> is of the form <span
class="math inline">\(MN\)</span>, which denotes the application of
function <span class="math inline">\(M\)</span> to argument <span
class="math inline">\(N\)</span>. Both <span
class="math inline">\(M\)</span> and <span
class="math inline">\(N\)</span> are themselves λ-terms.</p>
<p>The calculus is governed by three core equivalences:</p>
<ul>
<li><strong>α-conversion</strong> (<span
class="math inline">\(\alpha\)</span>): Renaming bound variables, <span
class="math inline">\(\lambda x. M \equiv \lambda y. M[x := y]\)</span>,
provided <span class="math inline">\(y\)</span> does not appear in <span
class="math inline">\(M\)</span>. For example, <span
class="math inline">\(\lambda x. x \equiv \lambda y. y\)</span> and
<span class="math inline">\(\lambda f. \lambda x. f\,x \equiv \lambda g.
\lambda z. g\,z\)</span>.</li>
<li><strong>β-reduction</strong> (<span
class="math inline">\(\beta\)</span>): Application, <span
class="math inline">\((\lambda x. M)N \rightarrow M[x := N]\)</span>,
substituting <span class="math inline">\(N\)</span> for free occurrences
of <span class="math inline">\(x\)</span> in <span
class="math inline">\(M\)</span>. For example, <span
class="math inline">\((\lambda x. x\,x)(\lambda y. y) \rightarrow
(\lambda y. y)(\lambda y. y) \rightarrow \lambda y. y\)</span>.</li>
<li><strong>η-conversion</strong> (<span
class="math inline">\(\eta\)</span>): Extensionality, <span
class="math inline">\(\lambda x. Mx \equiv M\)</span> when <span
class="math inline">\(x\)</span> is not free in <span
class="math inline">\(M\)</span>.</li>
</ul>
<p>Here <span class="math inline">\(M[x:=N]\)</span> denotes
substitution of <span class="math inline">\(N\)</span> for all free
occurrences of <span class="math inline">\(x\)</span> in <span
class="math inline">\(M\)</span>. From these simple rules emerges a
computational system as powerful as any programming language or Turing
machine.</p>
<h3 id="λ-calculus-as-a-formal-language">λ-Calculus as a Formal
Language</h3>
<p>Let us fix a countably infinite set of variable symbols <span
class="math inline">\(\mathcal{V} = \{x, y, z, x_1, x_2,
\dots\}\)</span>. The λ-calculus defines a formal language over this
alphabet by means of a context-free grammar. In Backus–Naur Form (BNF),
the set <span class="math inline">\(\Lambda\)</span> of λ-expressions
(or <em>terms</em>) is defined by the following production rules:</p>
<p><span class="math display">\[
\begin{array}{rl}
M ::= &amp; x \mid \lambda x. M \mid M\,M
\end{array}
\]</span></p>
<p>where <span class="math inline">\(x \in \mathcal{V}\)</span>. This
grammar states that every term <span class="math inline">\(M \in
\Lambda\)</span> is either:</p>
<ul>
<li>a variable symbol;</li>
<li>an abstraction <span class="math inline">\(\lambda x. M\)</span>,
denoting a function with formal parameter <span
class="math inline">\(x\)</span> and body <span
class="math inline">\(M\)</span>;</li>
<li>or an application <span class="math inline">\(M_1\, M_2\)</span>,
denoting the application of one term to another.</li>
</ul>
<p>The formal language generated by this grammar is the smallest set
<span class="math inline">\(\Lambda \subseteq
\text{Expr}(\mathcal{V})\)</span> satisfying the following inductive
clauses:</p>
<ol type="1">
<li>If <span class="math inline">\(x \in \mathcal{V}\)</span>, then
<span class="math inline">\(x \in \Lambda\)</span>;</li>
<li>If <span class="math inline">\(x \in \mathcal{V}\)</span> and <span
class="math inline">\(M \in \Lambda\)</span>, then <span
class="math inline">\(\lambda x. M \in \Lambda\)</span>;</li>
<li>If <span class="math inline">\(M_1, M_2 \in \Lambda\)</span>, then
<span class="math inline">\(M_1\, M_2 \in \Lambda\)</span>.</li>
</ol>
<h3 id="abstract-syntax-trees">Abstract Syntax Trees</h3>
<p>Abstract syntax trees are inductively defined algebraic data
structures that capture the hierarchical structure of expressions. The
set of abstract syntax trees for λ-calculus corresponds to the following
inductive type:</p>
<p><span class="math display">\[
\text{Term} ::=
\begin{cases}
\text{Var}(x) &amp; \text{for } x \in \mathcal{V} \\
\text{Lam}(x, M) &amp; \text{for } x \in \mathcal{V},\ M \in \text{Term}
\\
\text{Appl}(M_1, M_2) &amp; \text{for } M_1, M_2 \in \text{Term}
\end{cases}
\]</span></p>
<p>Thus, every λ-expression corresponds canonically to a <em>binary</em>
tree whose internal nodes are labeled by syntactic constructors
(abstraction, application), and whose leaves are variable names. The
concrete syntax, which includes parentheses, operator precedence, and
naming conventions, is merely a readable encoding of these trees. The
abstraction <span class="math inline">\(\lambda x. \lambda y.
x\,y\)</span> corresponds, in its tree form, to nested <code>Lam</code>
and <code>Appl</code> nodes.</p>
<p>In categorical terms, one can view this abstract syntax as the free
term algebra over the signature <span class="math inline">\(\Sigma =
\{\text{Var}, \text{Lam}, \text{Appl}\}\)</span>, where each operation
has arity <span class="math inline">\(\text{Var} :
\mathcal{V} \to \text{Term}\)</span>, <span
class="math inline">\(\text{Lam} : \mathcal{V} \times \text{Term} \to
\text{Term}\)</span>, and <span class="math inline">\(\text{Appl} :
\text{Term} \times \text{Term} \to \text{Term}\)</span>. The algebra of
terms then supports structural induction and recursion principles
naturally.</p>
<h3 id="magmas">Magmas</h3>
<p>A <strong>magma</strong> is the most basic algebraic structure: a set
equipped with a single binary operation. Formally, a magma is a pair
<span class="math inline">\((M, \cdot)\)</span>, where <span
class="math inline">\(M\)</span> is a nonempty set and <span
class="math inline">\(\cdot : M
\times M \to M\)</span> is a binary operation on <span
class="math inline">\(M\)</span>. Crucially, the definition imposes no
further conditions on the operation <span
class="math inline">\(\cdot\)</span>: it need not be associative,
commutative, nor admit an identity or inverse. In this sense, the magma
is the minimal algebraic structure supporting binary composition. For
example, the natural numbers <span
class="math inline">\(\mathbb{N}\)</span> with addition form a magma
<span class="math inline">\((\mathbb{N}, +)\)</span> that happens to be
both associative and unital (with identity element <span
class="math inline">\(0\)</span>), but these additional properties are
not required by the magma axioms.</p>
<p>Given a set <span class="math inline">\(A\)</span>, the <strong>free
magma</strong> <span class="math inline">\(\mathsf{M}(A)\)</span>
generated by <span class="math inline">\(A\)</span> is the initial
object in the category of magmas under the forgetful functor to sets. It
captures the formal, unrestricted compositions of elements of <span
class="math inline">\(A\)</span> under an abstract binary operation. The
set <span class="math inline">\(\mathsf{M}(A)\)</span> is defined
inductively as the smallest set satisfying:</p>
<ol type="1">
<li>For every <span class="math inline">\(a \in A\)</span>, the
singleton leaf <span class="math inline">\(a\)</span> belongs to <span
class="math inline">\(\mathsf{M}(A)\)</span>.</li>
<li>If <span class="math inline">\(x, y \in \mathsf{M}(A)\)</span>, then
the binary tree <span class="math inline">\((x \cdot y)\)</span> belongs
to <span class="math inline">\(\mathsf{M}(A)\)</span>.</li>
</ol>
<p>Here the binary operation <span class="math inline">\(\cdot\)</span>
is purely structural—it simply constructs a binary tree with two
subtrees, without any semantic interpretation or computation. There is
no requirement, for instance, that <span class="math inline">\((x \cdot
y) \cdot z = x \cdot (y \cdot z)\)</span>, and hence the shape of the
binary tree faithfully retains the syntactic structure of composition.
The operation is not associative, commutative, or subject to any
algebraic laws; it merely records the order and nesting of binary
combinations. Consequently, the expression <span
class="math inline">\(((a \cdot b) \cdot c)\)</span> is distinct from
<span class="math inline">\((a \cdot (b \cdot c))\)</span>, reflecting
that the operation preserves the exact parenthesization structure as
different tree shapes.</p>
<h3 id="free-magmas-and-binary-trees">Free Magmas and Binary Trees</h3>
<p>Algebraically, <span class="math inline">\(\mathsf{M}(A)\)</span>
consists of all finite binary trees whose leaves are labeled by elements
of <span class="math inline">\(A\)</span>, and whose internal nodes are
unlabeled and represent applications of the binary operation. Each such
tree corresponds to a fully parenthesized expression over <span
class="math inline">\(A\)</span>, where the parenthesization reflects
the binary structure.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Magma<span class="op">[</span>A<span class="op">]:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">op</span><span class="op">(</span>x<span class="op">:</span> A<span class="op">,</span> y<span class="op">:</span> A<span class="op">):</span> A</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">extension</span> <span class="op">(</span>x<span class="op">:</span> A<span class="op">)</span> <span class="kw">def</span> $ <span class="op">(</span>y<span class="op">:</span> A<span class="op">):</span> A <span class="op">=</span> <span class="fu">op</span><span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>enum BinTree<span class="op">[</span>A<span class="op">]:</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="fu">Leaf</span><span class="op">(</span>value<span class="op">:</span> A<span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="fu">Branch</span><span class="op">(</span>left<span class="op">:</span> BinTree<span class="op">[</span>A<span class="op">],</span> right<span class="op">:</span> BinTree<span class="op">[</span>A<span class="op">])</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> BinTree<span class="op">:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  given binTreeMagma<span class="op">[</span>A<span class="op">]:</span> Magma<span class="op">[</span>BinTree<span class="op">[</span>A<span class="op">]]</span> <span class="kw">with</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">op</span><span class="op">(</span>x<span class="op">:</span> BinTree<span class="op">[</span>A<span class="op">],</span> y<span class="op">:</span> BinTree<span class="op">[</span>A<span class="op">]):</span> BinTree<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="fu">Branch</span><span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> leaf<span class="op">[</span>A<span class="op">](</span>value<span class="op">:</span> A<span class="op">):</span> BinTree<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="fu">Leaf</span><span class="op">(</span>value<span class="op">)</span></span></code></pre></div>
<p>This construction is particularly important in the formal semantics
of programming languages and symbolic computation. The tree-like
structure of syntax is thus formally grounded in the algebraic notion of
a free magma.</p>
<h3 id="asts-of-λ-calculus-as-elements-of-a-free-magma">ASTs of
λ-Calculus as Elements of a Free Magma</h3>
<p>We may now formalize the idea that the <strong>abstract syntax trees
(ASTs)</strong> of the untyped λ-calculus can be encoded as elements of
the type <code>BinTree[Term[A]]</code>. This representation captures the
recursive binary structure of applications, while variables and
λ-abstractions are encoded as atomic leaves carrying term-level
information.</p>
<p>The key idea is that <strong>application</strong> is now encoded not
as a syntactic form in the term data type, but as the <em>structure of
the tree itself</em>. That is, the binary tree serves as a free magma on
<span class="math inline">\(\mathsf{Term}(A)\)</span>, with the binary
operation corresponding to application. We define a <code>Magma</code>
instance on <code>BinTree[A]</code> where the binary operation
<code>op(x, y)</code> constructs the application of one term to another
by forming a <code>Branch(x, y)</code>. Consequently, the expression
tree constructed by nested applications is built as a binary tree whose
leaves are labeled by atomic terms of type <code>Term[A]</code>, and
whose internal nodes represent application.</p>
<p>Let us make the <strong>semantic correspondence</strong> precise with
an example. If we write a term such as</p>
<p><span class="math display">\[
(\lambda x. x)\, (\lambda y. y)
\]</span></p>
<p>then it is represented as:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="kw">class</span> Var<span class="op">[</span>A<span class="op">](</span>index<span class="op">:</span> A<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="kw">class</span> Lambda<span class="op">[</span>A<span class="op">](</span>param<span class="op">:</span> Var<span class="op">[</span>A<span class="op">],</span> body<span class="op">:</span> BinTree<span class="op">[</span>Term<span class="op">[</span>A<span class="op">]])</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Term<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> Either<span class="op">[</span>Var<span class="op">[</span>A<span class="op">],</span> Lambda<span class="op">[</span>A<span class="op">]]</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">Branch</span><span class="op">(</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Leaf</span><span class="op">(</span><span class="fu">Right</span><span class="op">(</span><span class="fu">Lambda</span><span class="op">(</span><span class="fu">Var</span><span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">),</span> <span class="fu">Leaf</span><span class="op">(</span><span class="fu">Left</span><span class="op">(</span><span class="fu">Var</span><span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">)))))),</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Leaf</span><span class="op">(</span><span class="fu">Right</span><span class="op">(</span><span class="fu">Lambda</span><span class="op">(</span><span class="fu">Var</span><span class="op">(</span><span class="st">&quot;y&quot;</span><span class="op">),</span> <span class="fu">Leaf</span><span class="op">(</span><span class="fu">Left</span><span class="op">(</span><span class="fu">Var</span><span class="op">(</span><span class="st">&quot;y&quot;</span><span class="op">))))))</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>In this structure:</p>
<ul>
<li><code>Leaf(Right(...))</code> represents a λ-abstraction node,</li>
<li><code>Leaf(Left(...))</code> represents a variable reference,</li>
<li><code>Branch</code> composes subterms via application.</li>
</ul>
<p>From the standpoint of universal algebra, we observe that the set
<code>BinTree[Term[A]]</code> is precisely the <strong>free
magma</strong> generated by the set <code>Term[A]</code>, equipped with
the binary operation of application. The function <code>Branch</code>
serves as the magma’s binary operation, and <code>Leaf(t)</code> injects
atomic terms into the magma. This faithfully models the <em>concrete
application structure</em> of λ-calculus without conflating it with the
term constructors themselves.</p>
<h3 id="λ-calculus-as-a-magma-with-generators-and-relations">λ-Calculus
as a Magma with Generators and Relations</h3>
<p>The free magma structure models only the syntactic generation of
λ-expressions: it captures the inductive formation of terms via
variables, abstractions, and applications. However, the untyped
λ-calculus is not, in a semantic sense, a free magma. This is because
its equational theory includes nontrivial identifications among
syntactic expressions, namely those induced by the reduction rules of
α-, β-, and η-conversion. The presence of these equations requires
quotienting the syntactic magma by the congruence they generate.</p>
<p>The syntactic structure of the untyped λ-calculus can be described
algebraically as a magma generated by term constructors, subject to an
equational theory defined by the rewriting rules of α-conversion,
β-reduction, and η-conversion. This places λ-calculus within the
tradition of <strong>algebraic presentations by generators and
relations</strong>, analogous to defining a group as the quotient of a
free group by the normal closure of relations.</p>
<p>We begin with the observation that the raw syntax of λ-terms—before
any notion of reduction—is modeled by the <strong>free magma</strong>
<span class="math inline">\(\mathsf{FM}(T)\)</span>, freely generated by
the set <span class="math inline">\(T\)</span> of atomic terms (variable
symbols and λ-abstractions). The binary operation of the magma is
<strong>application</strong>, denoted syntactically by juxtaposition or,
in our formalization, by binary trees with application nodes. This free
magma contains all well-formed binary trees over atomic terms and admits
no identification beyond syntactic equality.</p>
<p>To define the λ-calculus proper, we impose an <strong>equational
theory</strong> <span
class="math inline">\(\equiv_{\alpha\beta\eta}\)</span> generated by the
rewriting rules of the <span
class="math inline">\(\lambda\)</span>-calculus. This theory induces a
congruence on the free magma <span
class="math inline">\(\mathsf{FM}(T)\)</span>. The quotient</p>
<p><span class="math display">\[
\Lambda := \mathsf{FM}(T) / {\equiv_{\alpha\beta\eta}}
\]</span></p>
<p>is the set of λ-terms modulo computation. Application remains a
well-defined binary operation on <span
class="math inline">\(\Lambda\)</span> because the congruence respects
application:</p>
<p><span class="math display">\[
M_1 \equiv M_1&#39;,\quad M_2 \equiv M_2&#39; \quad \Longrightarrow
\quad M_1\, M_2 \equiv M_1&#39;\, M_2&#39;.
\]</span></p>
<p>Hence, <span class="math inline">\(\Lambda\)</span> inherits a magma
structure from <span class="math inline">\(\mathsf{FM}(T)\)</span>,
though it is no longer free: the imposed equations identify many
syntactically distinct trees. The resulting structure <span
class="math inline">\((\Lambda,
\cdot)\)</span> is a <strong>quotient magma</strong>, analogous to how a
group defined by generators and relations is a quotient of the free
group.</p>
<p>This analogy becomes illuminating when we examine the computational
interpretation of composition. In group theory, multiplying two reduced
words may produce a non-reduced word, which is then simplified using the
group’s relations. For instance, if <span class="math inline">\(a^2 =
e\)</span>, then the product <span class="math inline">\(a \cdot a \cdot
b\)</span> reduces to <span class="math inline">\(b\)</span>. The key
property enabling this process to yield consistent results is <a
href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)"><strong>confluence</strong></a>:
any reduction sequence leads to a unique normal form (modulo
equivalence). This ensures that group multiplication is well-defined on
equivalence classes of reduced words.</p>
<p>The same principle holds in the λ-calculus. The <a
href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem"><strong>Church–Rosser
Theorem</strong></a> guarantees that the rewriting system generated by
<span class="math inline">\(\rightarrow_{\alpha\beta\eta}\)</span> is
confluent: if a term <span class="math inline">\(M\)</span> reduces to
both <span class="math inline">\(M_1\)</span> and <span
class="math inline">\(M_2\)</span>, then there exists a term <span
class="math inline">\(N\)</span> such that <span
class="math inline">\(M_1 \rightarrow^* N\)</span> and <span
class="math inline">\(M_2
\rightarrow^* N\)</span>. In other words, reduction paths are
joinable:</p>
<p><span class="math display">\[
M \twoheadrightarrow M_1,\quad M \twoheadrightarrow M_2 \quad
\Rightarrow \quad \exists N.\ M_1 \twoheadrightarrow N,\ M_2
\twoheadrightarrow N.
\]</span></p>
<p>This ensures that any reduction strategy, as long as it terminates,
yields a <strong>canonical representative</strong> of the equivalence
class <span class="math inline">\([M]\)</span>. Composition of
equivalence classes can therefore be implemented by composing
representatives and reducing the result to normal form.</p>
<p>Thus, just as in the group-theoretic case, one may view the
computation <span class="math inline">\([M] \cdot [N] := [M \cdot
N]\)</span> operationally as:</p>
<ol type="1">
<li>Compose the representatives <span class="math inline">\(M\)</span>
and <span class="math inline">\(N\)</span> via application;</li>
<li>Reduce the composite term <span class="math inline">\(M \cdot
N\)</span> using the rewriting system;</li>
<li>Return the equivalence class of the resulting normal form.</li>
</ol>
<p>In other words, the Church-Rosser Theorem is equivalent to the
following fact:</p>
<blockquote>
<p>The subset of the free magma <span
class="math inline">\(\mathsf{FM}(A)\)</span> recognized by the language
of <span class="math inline">\(\lambda\)</span>-calculus is a magma with
relations given by the reduction rules of the calculus.</p>
</blockquote>
<p>The crucial point is that this procedure is well-defined precisely
because the reduction system is confluent. In the absence of confluence,
different reduction strategies could yield incomparable normal forms,
and the quotient structure would be ill-posed.</p>
<h3 id="de-bruijn-encoding">De Bruijn Encoding</h3>
<p>A more effective approach to eliminate α-conversion is identifying a
<strong>canonical representative</strong> of each α-equivalence class,
which can be accomplished via the <a
href="https://en.wikipedia.org/wiki/De_Bruijn_index"><strong>de Bruijn
encoding</strong></a>. This encoding eliminates variable names entirely.
In the de Bruijn representation, each variable occurrence is replaced by
a natural number counting the abstractions between the variable
occurrence and its binder. The innermost binder corresponds to index 0,
the next outermost to index 1, and so on. For example:</p>
<p><span class="math display">\[
\lambda x. x \mapsto \lambda. 0, \qquad \lambda x. \lambda y. x \mapsto
\lambda. \lambda. 1
\]</span></p>
<p>The key property of this encoding is that two λ-expressions are
α-equivalent if and only if their de Bruijn representations are
syntactically identical. Thus, the quotient by α-equivalence is
canonically represented by nameless syntax.</p>
<p>This correspondence is formalized via a transformation:</p>
<p><span class="math display">\[
\mathsf{db} : \mathsf{BinTree}(\mathsf{Term}[A]) \to
\mathsf{BinTree}(\mathsf{Term}[\mathbb{N}]),
\]</span></p>
<p>where each leaf term <code>Var(a)</code> is replaced by
<code>Var(n)</code> for some <span class="math inline">\(n \in
\mathbb{N}\)</span>, computed with respect to its lexical depth. This
transformation is structure-preserving with respect to application, and
thus satisfies:</p>
<p><span class="math display">\[
\mathsf{db}(x \cdot y) = \mathsf{db}(x) \cdot \mathsf{db}(y),
\]</span></p>
<p>where the operation <span class="math inline">\(\cdot\)</span>
corresponds to binary application, implemented via tree branching. The
transformation on leaf terms is defined as:</p>
<p><span class="math display">\[
\mathsf{db}(\text{Leaf}(t)) = \text{Leaf}(\mathsf{db}_0(t)),
\]</span></p>
<p>where <span class="math inline">\(\mathsf{db}_0\)</span> converts
variables to indices relative to their binding context. This requires an
auxiliary context <span class="math inline">\(\Gamma \in
\mathsf{List}[A]\)</span>, which maintains the ordered stack of
currently bound variables. The transformation is defined recursively
as:</p>
<p><span class="math display">\[
\begin{aligned}
\mathsf{db}_\Gamma(\text{Var}(x)) &amp;:= \text{Var}(n) \quad
\text{where } x \text{ is at position } n \text{ in } \Gamma, \\
\mathsf{db}_\Gamma(\text{Lambda}(x, M)) &amp;:= \text{Lambda}(0,
\mathsf{db}_{x :: \Gamma}(M)), \\
\mathsf{db}_\Gamma(\text{Branch}(M_1, M_2)) &amp;:=
\text{Branch}(\mathsf{db}_\Gamma(M_1), \mathsf{db}_\Gamma(M_2)).
\end{aligned}
\]</span></p>
<p>The transformation <span
class="math inline">\(\mathsf{db}_\Gamma\)</span> thus replaces variable
names with their de Bruijn indices in a manner consistent with lexical
scoping and preserves the magma structure of application.</p>
<h3 id="catamorphisms">Catamorphisms</h3>
<p>A <a
href="https://en.wikipedia.org/wiki/Catamorphism"><strong>catamorphism</strong></a>
is the canonical homomorphism from an initial algebra into any other
algebra of the same signature. It formalizes the notion of structural
recursion or folding over inductively defined datatypes. In particular,
if <span class="math inline">\(\mu F\)</span> is the initial algebra of
a functor <span class="math inline">\(F\)</span>, and <span
class="math inline">\((A, \alpha: F(A) \to A)\)</span> is an <span
class="math inline">\(F\)</span>-algebra, then there exists a unique
morphism <span class="math inline">\([\alpha]: \mu F \to A\)</span>
making the diagram commute. This morphism <span
class="math inline">\([\alpha]\)</span> is the catamorphism induced by
<span class="math inline">\(\alpha\)</span>, and it implements recursion
over the structure of elements of <span class="math inline">\(\mu
F\)</span> by collapsing them into values of type <span
class="math inline">\(A\)</span> using the operations defined by <span
class="math inline">\(\alpha\)</span>.</p>
<p>In the present setting, the inductive data structure under
consideration is the term tree <span
class="math inline">\(\mathsf{Expr}(A) :=
\mathsf{BinTree}(\mathsf{Term}[A])\)</span>, representing expressions in
the untyped λ-calculus as binary trees of atomic terms. This structure
is governed by the functor</p>
<p><span class="math display">\[
F_A(X) = A + X \times X,
\]</span></p>
<p>where <span class="math inline">\(A = \mathsf{Term}[A]\)</span> is
the base set of leaf terms, and the inductive structure arises from the
binary operation of application. A catamorphism over <span
class="math inline">\(\mathsf{BinTree}(A)\)</span> amounts to defining a
function <span class="math inline">\(f : \mathsf{BinTree}(A) \to
B\)</span> such that</p>
<p><span class="math display">\[
f(\text{Leaf}(a)) = \phi(a), \quad f(\text{Branch}(x, y)) = f(x) \cdot
f(y),
\]</span></p>
<p>where <span class="math inline">\(\phi : A \to B\)</span> and <span
class="math inline">\(\cdot\)</span> is the binary operation on <span
class="math inline">\(B\)</span> making it an algebra for <span
class="math inline">\(F_A\)</span>.</p>
<p>The de Bruijn transformation <span
class="math inline">\(\mathsf{db}_\Gamma :
\mathsf{BinTree}(\mathsf{Term}[A]) \to
\mathsf{BinTree}(\mathsf{Term}[\mathbb{N}])\)</span> is an instance of
such a catamorphism, albeit enriched by context sensitivity. It
collapses the tree structure by applying a context-aware algebra:</p>
<p><span class="math display">\[
\alpha_\Gamma : \mathsf{Term}[A] + (\mathsf{BinTree}(\mathsf{Term}[A])
\times \mathsf{BinTree}(\mathsf{Term}[A])) \to
\mathsf{BinTree}(\mathsf{Term}[\mathbb{N}]),
\]</span></p>
<p>which operates as follows. If the node is a variable <span
class="math inline">\(\text{Var}(x)\)</span>, it is mapped to <span
class="math inline">\(\text{Var}(n)\)</span> where <span
class="math inline">\(x\)</span> is at position <span
class="math inline">\(n\)</span> in <span
class="math inline">\(\Gamma\)</span>. If the node is a λ-abstraction
<span class="math inline">\(\text{Lambda}(x, M)\)</span>, it is mapped
to <span class="math inline">\(\text{Lambda}(0, M&#39;)\)</span>, where
<span class="math inline">\(M&#39;\)</span> is obtained by recursively
applying the catamorphism to <span class="math inline">\(M\)</span>
under the extended context <span class="math inline">\(x ::
\Gamma\)</span>. If the node is a binary application <span
class="math inline">\(\text{Branch}(M_1, M_2)\)</span>, the catamorphism
descends into both subtrees and reconstructs the application node via
<span class="math inline">\(\text{Branch}(\cdot, \cdot)\)</span>.</p>
<p>Because the transformation satisfies</p>
<p><span class="math display">\[
\mathsf{db}_\Gamma(M_1 \cdot M_2) = \mathsf{db}_\Gamma(M_1) \cdot
\mathsf{db}_\Gamma(M_2),
\]</span></p>
<p>it is a homomorphism of magmas. Moreover, the threading of the
context <span class="math inline">\(\Gamma\)</span> throughout the
recursion preserves binding structure and enables the transformation to
compute de Bruijn indices correctly.</p>
<p>Although catamorphisms are typically defined for context-free
structural recursion, the de Bruijn transformation is an example of a
<strong>context-sensitive catamorphism</strong>, or more precisely a
<em>paramorphically enriched fold</em>, where additional information (in
this case, the context) is threaded through the recursion in a
principled way. This form of structural recursion with state is well
understood in categorical functional programming.</p>
<p>Thus, the de Bruijn transformation is a context-sensitive
catamorphism between two magmas: respectively between the subsets of
<code>BinTree[Term[A]]</code> and <code>BinTree[Term[Int]]</code>
recognized by the formal grammar of the <span
class="math inline">\(\lambda\)</span>-calculus. The tranformation
serves as a canonical normalization function that computes
representatives of α-equivalence classes in nameless form, thereby
eliminating the need for α-reduction as an explicit rewriting step. This
facilitates the definition of subsequent operations—such as substitution
and evaluation—in a purely structural and unambiguous manner.</p>
</body>
</html>
</section><div class="navigate">
<h2 id="older-posts">Older Posts</h2>
<p>[<strong>2025-06-11</strong>] <a
href="clean/2025-06-11-counting_points_of_elliptic_curves.html">Counting
Points of Elliptic Curves</a></p>
<p>[<strong>2025-04-23</strong>] <a
href="clean/2025-04-23-loday-coordinates.html">Loday Coordinates for
Associahedra</a></p>
<p>[<strong>2025-04-22</strong>] <a
href="clean/2025-04-22-associahedra.html">Integer Coordinates for
Associahedra</a></p>
<p>[<strong>2025-02-23</strong>] <a
href="clean/2025-02-23-counting-matroids.html">Counting Matroids</a></p>
<p>[<strong>2025-02-12</strong>] <a
href="clean/2025-02-12-sampling-from-a-distribution.html">Sampling from
a Random Variable</a></p>
<p>[<strong>2025-01-29</strong>] <a
href="clean/2025-01-29-markov-triples.html">Markov Numbers</a></p>
<p>[<strong>2024-12-24</strong>] <a
href="clean/2024-12-24-centralizers.html">Number of isomorphism classes
of simple graph (continued)</a></p>
<p>[<strong>2024-12-22</strong>] <a
href="clean/2024-12-22-counting-graphs.html">Counting Isomorphism
Classes of Graphs</a></p>
<p>[<strong>2024-11-25</strong>] <a
href="clean/2024-11-25-connected-components2.html">Connected Components
of Graphs</a></p>
<p>[<strong>2024-11-24</strong>] <a
href="clean/2024-11-24-connected-components.html">Counting connected
components of a graph</a></p>
<p>[<strong>2024-11-18</strong>] <a
href="clean/2024-11-18-counting-m-ary-trees.html">Counting Isomorphism
Classes of <span class="math inline"><em>m</em></span>-ary Trees</a></p>
<p>[<strong>2024-11-16</strong>] <a
href="clean/2024-11-16-counting-ternary-trees.html">Number of
Isomorphism Classes of Ternary Trees</a></p>
<p>[<strong>2024-11-12</strong>] <a
href="clean/2024-11-12-balanced-trees.html">Hosoya Index of Balanced
Binary Trees</a></p>
<p>[<strong>2024-11-11</strong>] <a
href="clean/2024-11-11-hosoya-index.html">Hosoya Index of a
Graph</a></p>
<p>[<strong>2024-10-29</strong>] <a
href="clean/2024-10-29-clique-number.html">The Clique Number of a Simple
Graph</a></p>
<p>[<strong>2024-10-28</strong>] <a
href="clean/2024-10-28-maximum-independent-set.html">The Size of
Maximally Independent Subsets in a Graph</a></p>
<p>[<strong>2023-11-03</strong>] <a
href="clean/2023-11-03-jgrapht-interop-with-common-lisp.html">Graph
Algorithms in JGraphT with Common Lisp</a></p>
<p>[<strong>2023-10-28</strong>] <a
href="clean/2023-10-28-implementation-of-cut-and-qcut-in-lisp.html">An
Implementation of Pandas’ <code>cut</code> and <code>qcut</code> in
Lisp</a></p>
<p>[<strong>2023-07-24</strong>] <a
href="clean/2023-07-24-a_collatz-like_conjecture_for_the_projective_line.html">A
Collatz-like Conjecture for the Projective Line</a></p>
<p>[<strong>2023-03-06</strong>] <a
href="clean/2023-03-06-twin_primes_cousin_primes_sexy_primes_and_prime_triplets.html">Twin
Primes, Cousin Primes, Sexy Primes, and Prime Triplets</a></p>
<p>[<strong>2023-03-02</strong>] <a
href="clean/2023-03-02-set_of_all_partitions_of_a_finite_set.html">Set
of All Partitions of a Finite Set</a></p>
<p>[<strong>2023-02-14</strong>] <a
href="clean/2023-02-14-non-crossing_partitions_and_dyck_words.html">Non-crossing
Partitions and Dyck Words</a></p>
<p>[<strong>2023-02-13</strong>] <a
href="clean/2023-02-13-non-crossing_linear_chords.html">Non-crossing
Linear Chords</a></p>
<p>[<strong>2023-02-04</strong>] <a
href="clean/2023-02-04-clojurepython_interop_examples.html">Clojure/Python
Interop Examples</a></p>
<p>[<strong>2023-01-14</strong>] <a
href="clean/2023-01-14-graph_algorithms_in_clojure_with_jgrapht.html">Graph
Algorithms in Clojure with JGraphT</a></p>
<p>[<strong>2022-03-29</strong>] <a
href="clean/2022-03-29-2d-random_walk.html">2D-Random Walk</a></p>
<p>[<strong>2022-03-28</strong>] <a
href="clean/2022-03-28-trade_deficit_vs_exchange_rate_curve.html">Trade
Deficit vs Exchange Rate Curve</a></p>
<p>[<strong>2022-03-16</strong>] <a
href="clean/2022-03-16-working_with_world_bank_data_in_python.html">Working
with World Bank Data in Python</a></p>
<p>[<strong>2022-03-09</strong>] <a
href="clean/2022-03-09-working_with_european_central_bank_data_in_python_revisited.html">Working
with European Central Bank data in python (revisited)</a></p>
<p>[<strong>2022-01-24</strong>] <a
href="clean/2022-01-24-a_clique_analysis_of_quakers_in_early_modern_britain_1500-1700.html">A
Clique Analysis of Quakers in early modern Britain (1500-1700)</a></p>
<p>[<strong>2021-12-05</strong>] <a
href="clean/2021-12-05-boyermoore_and_misra-gries_algorithms_in_clojure.html">Boyer–Moore
and Misra-Gries Algorithms in Clojure</a></p>
<p>[<strong>2021-09-12</strong>] <a
href="clean/2021-09-12-tension_in_text_plotted.html">Tension in Text
Plotted</a></p>
<p>[<strong>2021-09-02</strong>] <a
href="clean/2021-09-02-statistical_distributions_using_apache_commons_math_in_clojure.html">Statistical
Distributions using Apache Commons Math in Clojure</a></p>
<p>[<strong>2021-08-31</strong>] <a
href="clean/2021-08-31-reduce_with_intermediate_results_in_common_lisp.html">Reduce
with Intermediate Results in Common Lisp</a></p>
<p>[<strong>2021-08-21</strong>] <a
href="clean/2021-08-21-multivariate_regression_implemented_in_clojure.html">Multivariate
Regression Implemented in Clojure</a></p>
<p>[<strong>2021-05-29</strong>] <a
href="clean/2021-05-29-using_neural_networks_to_detect_graph_properties.html">Using
Neural Networks to Detect Graph Properties</a></p>
<p>[<strong>2021-04-17</strong>] <a
href="clean/2021-04-17-fast_null-space_calculation_via_lu-decomposition.html">Fast
Null-Space Calculation via LU-Decomposition</a></p>
<p>[<strong>2021-02-24</strong>] <a
href="clean/2021-02-24-stoer-wagner_algorithm_in_clojure.html">Stoer-Wagner
Algorithm in Clojure</a></p>
<p>[<strong>2021-02-19</strong>] <a
href="clean/2021-02-19-calculating_vertex_covers_in_clojure.html">Calculating
Vertex Covers in Clojure</a></p>
<p>[<strong>2021-02-18</strong>] <a
href="clean/2021-02-18-listing_all_paths_in_a_graph.html">Listing All
Paths in a Graph</a></p>
<p>[<strong>2021-02-14</strong>] <a
href="clean/2021-02-14-strict_dyck_words_and_fibonacci_numbers.html">Strict
Dyck Words and Fibonacci Numbers</a></p>
<p>[<strong>2021-02-14</strong>] <a
href="clean/2021-02-14-kruskals_algorithm_in_common_lisp.html">Kruskal’s
Algorithm in Common Lisp</a></p>
<p>[<strong>2021-02-13</strong>] <a
href="clean/2021-02-13-kruskals_algorithm_implemented_in_clojure.html">Kruskal's
Algorithm Implemented in Clojure</a></p>
<p>[<strong>2021-02-10</strong>] <a
href="clean/2021-02-10-an_integer_dynamical_system_of_integers.html">An
integer dynamical system of integers</a></p>
<p>[<strong>2021-02-08</strong>] <a
href="clean/2021-02-08-binary_symmetrization.html">Binary
Symmetrization</a></p>
<p>[<strong>2021-01-28</strong>] <a
href="clean/2021-01-28-prüfer_encoding_and_decoding_of_a_tree_in_clojure.html">Prüfer
Encoding and Decoding of a Tree in Clojure</a></p>
<p>[<strong>2021-01-27</strong>] <a
href="clean/2021-01-27-counting_cycle-free_paths_in_a_graph.html">Counting
Cycle-Free Paths in a Graph</a></p>
<p>[<strong>2021-01-27</strong>] <a
href="clean/2021-01-27-counting_connected_labeled_graphs.html">Counting
Connected Labeled Graphs</a></p>
<p>[<strong>2020-12-18</strong>] <a
href="clean/2020-12-18-counting_graphs_with_a_prescribed_degree_sequence.html">Counting
Graphs with a Prescribed Degree Sequence</a></p>
<p>[<strong>2020-12-13</strong>] <a
href="clean/2020-12-13-havelhakimi_algorithm_in_clojure.html">Havel–Hakimi
Algorithm in Clojure</a></p>
<p>[<strong>2020-12-12</strong>] <a
href="clean/2020-12-12-havelhakimi_algorithm_in_common-lisp.html">Havel–Hakimi
Algorithm in Common-Lisp</a></p>
<p>[<strong>2020-10-23</strong>] <a
href="clean/2020-10-23-the_quadratic_casimir_element.html">The Quadratic
Casimir Element</a></p>
<p>[<strong>2020-07-04</strong>] <a
href="clean/2020-07-04-collatz_sequence_in_binary.html">Collatz Sequence
in Binary</a></p>
<p>[<strong>2020-07-02</strong>] <a
href="clean/2020-07-02-a_lazy_sequence_of_primes_in_clojure.html">A Lazy
Sequence of Primes in Clojure</a></p>
<p>[<strong>2020-06-10</strong>] <a
href="clean/2020-06-10-yet_another_fizz-buzz_in_common_lisp.html">Yet
Another Fizz-Buzz in Common Lisp</a></p>
<p>[<strong>2020-05-12</strong>] <a
href="clean/2020-05-12-ecb_data_with_clojure_and_vega-lite.html">ECB
Data with Clojure and Vega-Lite</a></p>
<p>[<strong>2020-05-06</strong>] <a
href="clean/2020-05-06-processing_ecb_data_with_common_lisp.html">Processing
ECB Data with Common Lisp</a></p>
<p>[<strong>2020-04-17</strong>] <a
href="clean/2020-04-17-next_permutation_in_the_lexicographical_ordering.html">Next
Permutation in the Lexicographical Ordering</a></p>
<p>[<strong>2020-04-13</strong>] <a
href="clean/2020-04-13-turkish_hyphenation_in_common_lisp.html">Turkish
Hyphenation in Common Lisp</a></p>
<p>[<strong>2020-04-01</strong>] <a
href="clean/2020-04-01-using_javaplex_with_clojure.html">Using JavaPlex
with Clojure</a></p>
<p>[<strong>2019-11-05</strong>] <a
href="clean/2019-11-05-constricted_arithmetic_progressions.html">Constricted
Arithmetic Progressions</a></p>
<p>[<strong>2019-11-03</strong>] <a
href="clean/2019-11-03-the_number_of_arithmetic_progressions_of_integers.html">The
Number of Arithmetic Progressions of Integers</a></p>
<p>[<strong>2019-05-06</strong>] <a
href="clean/2019-05-06-bron-kerbosch_algorithm_in_clojure.html">Bron-Kerbosch
Algorithm in Clojure</a></p>
<p>[<strong>2019-05-01</strong>] <a
href="clean/2019-05-01-an_implementation_of_ford-fulkerson_algorithm_in_clojure.html">An
Implementation of Ford-Fulkerson Algorithm in Clojure</a></p>
<p>[<strong>2019-04-22</strong>] <a
href="clean/2019-04-22-document_summarization_via_nonnegative_matrix_factorization.html">Document
Summarization via Nonnegative Matrix Factorization</a></p>
<p>[<strong>2019-04-20</strong>] <a
href="clean/2019-04-20-latent_semantic_analysis_in_clojure.html">Latent
Semantic Analysis in Clojure</a></p>
<p>[<strong>2019-04-13</strong>] <a
href="clean/2019-04-13-k-nearest_neighbors_algorithm_in_clojure.html">K-Nearest
Neighbors Algorithm in Clojure</a></p>
<p>[<strong>2019-04-06</strong>] <a
href="clean/2019-04-06-k-means_implemented_in_clojure.html">K-Means
Implemented in Clojure</a></p>
<p>[<strong>2019-03-19</strong>] <a
href="clean/2019-03-19-prüfer_encodingdecoding_of_a_tree_in_common_lisp.html">Prüfer
Encoding/Decoding of a Tree in Common Lisp</a></p>
<p>[<strong>2019-03-05</strong>] <a
href="clean/2019-03-05-gale-shaply_algorithm_in_common_lisp.html">Gale-Shaply
Algorithm in Common Lisp</a></p>
<p>[<strong>2019-03-02</strong>] <a
href="clean/2019-03-02-calculating_the_correct_rank_of_a_matrix.html">Calculating
The Correct Rank of a Matrix</a></p>
<p>[<strong>2018-12-04</strong>] <a
href="clean/2018-12-04-feed-forward_and_back-propagation_in_neural_networks_as_left-_and_right-fold.html">Feed-forward
and back-propagation in neural networks as left- and right-fold</a></p>
<p>[<strong>2018-10-31</strong>] <a
href="clean/2018-10-31-nonnegative_matrix_decomposition_in_clojure.html">Nonnegative
Matrix Decomposition in Clojure</a></p>
<p>[<strong>2018-10-30</strong>] <a
href="clean/2018-10-30-non-negative_matrix_decomposition_in_scala.html">Non-negative
Matrix Decomposition in Scala</a></p>
<p>[<strong>2018-08-30</strong>] <a
href="clean/2018-08-30-working_with_european_central_bank_data_in_scala.html">Working
with European Central Bank Data in Scala</a></p>
<p>[<strong>2018-07-30</strong>] <a
href="clean/2018-07-30-perverse_sequences.html">Perverse
Sequences</a></p>
<p>[<strong>2018-05-28</strong>] <a
href="clean/2018-05-28-online_perceptron_in_common_lisp.html">Online
Perceptron in Common Lisp</a></p>
<p>[<strong>2018-05-26</strong>] <a
href="clean/2018-05-26-online_perceptron.html">Online Perceptron</a></p>
<p>[<strong>2018-05-18</strong>] <a
href="clean/2018-05-18-online_regression.html">Online Regression</a></p>
<p>[<strong>2018-05-06</strong>] <a
href="clean/2018-05-06-knuts_algorithm-s_in_common_lisp.html">Knut’s
Algorithm-S in Common Lisp</a></p>
<p>[<strong>2018-02-28</strong>] <a
href="clean/2018-02-28-irreducible_dyck_words.html">Irreducible Dyck
Words</a></p>
<p>[<strong>2018-02-19</strong>] <a
href="clean/2018-02-19-optimization_with_gnu_scientific_library_for_lisp.html">Optimization
with GNU Scientific Library for Lisp</a></p>
<p>[<strong>2018-02-10</strong>] <a
href="clean/2018-02-10-van_ecks_sequence.html">Van Eck’s
Sequence</a></p>
<p>[<strong>2018-02-09</strong>] <a
href="clean/2018-02-09-hiring_networks_in_mathematics.html">Hiring
networks in mathematics</a></p>
<p>[<strong>2018-02-08</strong>] <a
href="clean/2018-02-08-linus_sequence.html">Linus Sequence</a></p>
<p>[<strong>2018-02-05</strong>] <a
href="clean/2018-02-05-egyptian_fractions.html">Egyptian
Fractions</a></p>
<p>[<strong>2018-02-01</strong>] <a
href="clean/2018-02-01-listing_all_young_tableaux.html">Listing all
Young Tableaux</a></p>
<p>[<strong>2018-01-23</strong>] <a
href="clean/2018-01-23-collatz_sequence_yet_again.html">Collatz sequence
(yet again)</a></p>
<p>[<strong>2018-01-15</strong>] <a
href="clean/2018-01-15-hofstadters_q_sequence.html">Hofstadter's Q
sequence</a></p>
<p>[<strong>2018-01-09</strong>] <a
href="clean/2018-01-09-farey_sequence.html">Farey Sequence</a></p>
<p>[<strong>2018-01-09</strong>] <a
href="clean/2018-01-09-catalans_triangle.html">Catalan's
Triangle</a></p>
<p>[<strong>2018-01-06</strong>] <a
href="clean/2018-01-06-the_shoelace_formula_for_the_area_of_a_polygon.html">The
Shoelace Formula for the Area of a Polygon</a></p>
<p>[<strong>2017-10-01</strong>] <a
href="clean/2017-10-01-working_with_european_central_bank_data_in_python.html">Working
with European Central Bank Data in Python</a></p>
<p>[<strong>2017-09-27</strong>] <a
href="clean/2017-09-27-expected_value_of_the_diameter_of_a_tree.html">Expected
Value of the Diameter of a Tree</a></p>
<p>[<strong>2017-09-26</strong>] <a
href="clean/2017-09-26-using_quandl_with_kixistats_on_clojure.html">Using
Quandl with kixi.stats on Clojure</a></p>
<p>[<strong>2017-09-22</strong>] <a
href="clean/2017-09-22-using_quandl_with_common_lisp.html">Using Quandl
with Common Lisp</a></p>
<p>[<strong>2017-08-05</strong>] <a
href="clean/2017-08-05-solving_linear_equations_in_natural_numbers.html">Solving
Linear Equations in Natural Numbers</a></p>
<p>[<strong>2017-07-31</strong>] <a
href="clean/2017-07-31-transitive_closure_of_a_directed_graph_or_a_relation.html">Transitive
Closure of a Directed Graph or a Relation</a></p>
<p>[<strong>2017-07-20</strong>] <a
href="clean/2017-07-20-steenrod-milnor_and_tournament_sequences.html">Steenrod-Milnor
and Tournament Sequences</a></p>
<p>[<strong>2017-07-15</strong>] <a
href="clean/2017-07-15-a_lower_bound_on_the_radius_of_a_graph.html">A
lower bound on the radius of a graph</a></p>
<p>[<strong>2017-07-08</strong>] <a
href="clean/2017-07-08-all_partitions_of_an_integer.html">All partitions
of an integer</a></p>
<p>[<strong>2017-07-06</strong>] <a
href="clean/2017-07-06-some_hasse_diagrams.html">Some Hasse
Diagrams</a></p>
<p>[<strong>2017-07-04</strong>] <a
href="clean/2017-07-04-shuffles.html">Shuffles</a></p>
<p>[<strong>2017-07-03</strong>] <a
href="clean/2017-07-03-kaprekar_sequence.html">Kaprekar Sequence</a></p>
<p>[<strong>2017-07-01</strong>] <a
href="clean/2017-07-01-lattice_of_dyck_words.html">Lattice of Dyck
Words</a></p>
<p>[<strong>2017-06-28</strong>] <a
href="clean/2017-06-28-the_poset_of_connected_subgraphs_of_a_connected_graph.html">The
poset of connected subgraphs of a connected graph</a></p>
<p>[<strong>2017-06-21</strong>] <a
href="clean/2017-06-21-calculating_the_diameter_and_the_radius_of_a_graph_using_tropic_linear_algebra.html">Calculating
the Diameter and the Radius of a Graph Using Tropic Linear
Algebra</a></p>
<p>[<strong>2017-06-19</strong>] <a
href="clean/2017-06-19-generating_random_regular_graphs.html">Generating
random regular graphs</a></p>
<p>[<strong>2017-06-14</strong>] <a
href="clean/2017-06-14-estimating_the_maximum_element_of_a_large_list.html">Estimating
the maximum element of a large list</a></p>
<p>[<strong>2017-06-09</strong>] <a
href="clean/2017-06-09-a_stochastic_gradient_descent_implementation_in_clojure.html">A
Stochastic Gradient Descent Implementation in Clojure</a></p>
<p>[<strong>2017-06-06</strong>] <a
href="clean/2017-06-06-a_topology_problem.html">A topology
problem</a></p>
<p>[<strong>2017-04-22</strong>] <a
href="clean/2017-04-22-listing_duplicate_files.html">Listing duplicate
files</a></p>
<p>[<strong>2017-03-14</strong>] <a
href="clean/2017-03-14-my_first_idris_proof.html">My First Idris
Proof</a></p>
<p>[<strong>2016-12-02</strong>] <a
href="clean/2016-12-02-distinguishing_hash_functions_part_ii.html">Distinguishing
hash functions (part II)</a></p>
<p>[<strong>2016-12-01</strong>] <a
href="clean/2016-12-01-distinguishing_hash_functions.html">Distinguishing
hash functions</a></p>
<p>[<strong>2016-10-20</strong>] <a
href="clean/2016-10-20-hofstadter-conway_10000_sequence.html">Hofstadter-Conway
$10,000 sequence</a></p>
<p>[<strong>2016-08-18</strong>] <a
href="clean/2016-08-18-a_solution_for_problem_171_of_4clojure.html">A
Solution for Problem 171 of 4Clojure</a></p>
<p>[<strong>2016-08-16</strong>] <a
href="clean/2016-08-16-puzzles_and_group_theory.html">Puzzles and Group
Theory</a></p>
<p>[<strong>2016-08-13</strong>] <a
href="clean/2016-08-13-using_weka_within_lisp.html">Using Weka within
Lisp</a></p>
<p>[<strong>2016-07-12</strong>] <a
href="clean/2016-07-12-funniest_and_unfunniest_jokes_in_the_jester_dataset.html">Funniest
and Unfunniest Jokes in the Jester Dataset</a></p>
<p>[<strong>2016-07-05</strong>] <a
href="clean/2016-07-05-generating_uniformly_random_connected_graphs.html">Generating
Uniformly Random Connected Graphs</a></p>
<p>[<strong>2016-06-16</strong>] <a
href="clean/2016-06-16-the_robinson-schensted_algorithm.html">The
Robinson-Schensted Algorithm</a></p>
<p>[<strong>2016-06-01</strong>] <a
href="clean/2016-06-01-conjugate_partitions.html">Conjugate
Partitions</a></p>
<p>[<strong>2016-04-27</strong>] <a
href="clean/2016-04-27-using_word2vec_from_clojure.html">Using Word2Vec
from Clojure</a></p>
<p>[<strong>2016-04-24</strong>] <a
href="clean/2016-04-24-using_word2vec_from_common_lisp.html">Using
Word2Vec from Common Lisp</a></p>
<p>[<strong>2016-04-18</strong>] <a
href="clean/2016-04-18-a_migration_analysis.html">A Migration
Analysis</a></p>
<p>[<strong>2016-04-11</strong>] <a
href="clean/2016-04-11-basic_data_analysis_with_cl_without_frameworks.html">Basic
Data Analysis with CL without Frameworks</a></p>
<p>[<strong>2016-03-25</strong>] <a
href="clean/2016-03-25-parallel_map-reduce_in_common_lisp.html">Parallel
map-reduce in Common Lisp</a></p>
<p>[<strong>2016-02-22</strong>] <a
href="clean/2016-02-22-text_summarization_and_topic_analysis.html">Text
Summarization and Topic Analysis</a></p>
<p>[<strong>2016-01-27</strong>] <a
href="clean/2016-01-27-set_covering_problem.html">Set Covering
Problem</a></p>
<p>[<strong>2016-01-25</strong>] <a
href="clean/2016-01-25-kolmogorov-smirnov_test.html">Kolmogorov-Smirnov
Test</a></p>
<p>[<strong>2016-01-20</strong>] <a
href="clean/2016-01-20-eigen-values_of_the_laplacian_and_connected_components_of_a_graph.html">Eigen-values
of the Laplacian and Connected Components of a Graph</a></p>
<p>[<strong>2015-12-12</strong>] <a
href="clean/2015-12-12-dual_graphs.html">Dual Graphs</a></p>
<p>[<strong>2015-10-26</strong>] <a
href="clean/2015-10-26-longest_increasing_subsequence_revisited.html">Longest
Increasing Subsequence Revisited</a></p>
<p>[<strong>2015-10-16</strong>] <a
href="clean/2015-10-16-document_summarization_via_markov_chains.html">Document
Summarization via Markov Chains</a></p>
<p>[<strong>2015-10-07</strong>] <a
href="clean/2015-10-07-computational_literary_analysis.html">Computational
Literary Analysis</a></p>
<p>[<strong>2015-09-30</strong>] <a
href="clean/2015-09-30-library_of_babel_in_common_lisp.html">Library of
Babel in Common Lisp</a></p>
<p>[<strong>2015-09-28</strong>] <a
href="clean/2015-09-28-merging_association_lists_in_common_lisp.html">Merging
Association Lists in Common Lisp</a></p>
<p>[<strong>2015-07-22</strong>] <a
href="clean/2015-07-22-cheapest_paths_via_tropic_matrices.html">Cheapest
Paths via Tropic Matrices</a></p>
<p>[<strong>2015-07-21</strong>] <a
href="clean/2015-07-21-hidden_markov_models_via_tropic_matrices.html">Hidden
Markov Models via Tropic Matrices</a></p>
<p>[<strong>2015-07-08</strong>] <a
href="clean/2015-07-08-a_non-technical_post.html">A non-technical
post</a></p>
<p>[<strong>2015-06-28</strong>] <a
href="clean/2015-06-28-an_implementation_of_the_viterbi_algorithm_in_common_lisp.html">An
implementation of the Viterbi algorithm in Common Lisp</a></p>
<p>[<strong>2015-05-28</strong>] <a
href="clean/2015-05-28-greatest_common_divisor_of_two_rational_numbers.html">Greatest
Common Divisor of Two Rational Numbers</a></p>
<p>[<strong>2015-05-21</strong>] <a
href="clean/2015-05-21-partitions_of_equal_measure_whatever_the_measure_may_be.html">Partitions
of Equal Measure Whatever the Measure May Be</a></p>
<p>[<strong>2015-05-14</strong>] <a
href="clean/2015-05-14-finding_cliques_in_a_graph.html">Finding Cliques
in a Graph</a></p>
<p>[<strong>2015-05-12</strong>] <a
href="clean/2015-05-12-set_cover_problem.html">Set Cover Problem</a></p>
<p>[<strong>2015-05-03</strong>] <a
href="clean/2015-05-03-threading_macros_in_common_lisp.html">Threading
Macros in Common Lisp</a></p>
<p>[<strong>2015-05-03</strong>] <a
href="clean/2015-05-03-happy_numbers.html">Happy Numbers</a></p>
<p>[<strong>2015-05-01</strong>] <a
href="clean/2015-05-01-collatz_primes.html">Collatz Primes</a></p>
<p>[<strong>2015-04-23</strong>] <a
href="clean/2015-04-23-splitting_streams.html">Splitting Streams</a></p>
<p>[<strong>2015-04-06</strong>] <a
href="clean/2015-04-06-hamming_distance_and_double_hashing.html">Hamming
Distance and Double Hashing</a></p>
<p>[<strong>2015-04-05</strong>] <a
href="clean/2015-04-05-hamming_distance_and_hashing_functions.html">Hamming
Distance and Hashing Functions</a></p>
<p>[<strong>2015-04-05</strong>] <a
href="clean/2015-04-05-hamming_derivative_of_hashing_functions.html">Hamming
Derivative of Hashing Functions</a></p>
<p>[<strong>2015-04-02</strong>] <a
href="clean/2015-04-02-a_topology_problem.html">A Topology
Problem</a></p>
<p>[<strong>2015-03-21</strong>] <a
href="clean/2015-03-21-curve_fitting_is_a_gram-schmidt_reduction.html">Curve
Fitting is a Gram-Schmidt Reduction</a></p>
<p>[<strong>2015-03-08</strong>] <a
href="clean/2015-03-08-maximum_number_of_characters_using_keystrokes_a_ctrla_ctrlc_and_ctrlv.html">Maximum
number of characters using keystrokes A, Ctrl+A, Ctrl+C and
Ctrl+V</a></p>
<p>[<strong>2015-03-06</strong>] <a
href="clean/2015-03-06-eccentricity_radius_and_diameter_in_a_graph_revisited.html">Eccentricity,
Radius and Diameter in a Graph, Revisited</a></p>
<p>[<strong>2015-03-01</strong>] <a
href="clean/2015-03-01-graphs_and_entropy.html">Graphs and
Entropy</a></p>
<p>[<strong>2015-02-22</strong>] <a
href="clean/2015-02-22-math_phd_hiring_network_part_3.html">Math PhD
Hiring Network (Part 3)</a></p>
<p>[<strong>2015-02-19</strong>] <a
href="clean/2015-02-19-math_phd_hiring_network_part_2.html">Math PhD
Hiring Network (Part 2)</a></p>
<p>[<strong>2015-02-18</strong>] <a
href="clean/2015-02-18-math_phd_hiring_network_part_1.html">Math PhD
Hiring Network (Part 1)</a></p>
<p>[<strong>2015-02-17</strong>] <a
href="clean/2015-02-17-faculty_networks_and_inequality_in_hiring_practices_in_universities.html">Faculty
Networks and Inequality in Hiring Practices in Universities</a></p>
<p>[<strong>2015-02-10</strong>] <a
href="clean/2015-02-10-functional_streams_in_lisp_explained.html">Functional
Streams in Lisp Explained</a></p>
<p>[<strong>2015-02-05</strong>] <a
href="clean/2015-02-05-collatz-type_conjectures_continued.html">Collatz-type
Conjectures (Continued)</a></p>
<p>[<strong>2015-02-04</strong>] <a
href="clean/2015-02-04-collatz-type_conjectures_continued.html">Collatz-type
Conjectures (Continued)</a></p>
<p>[<strong>2015-01-31</strong>] <a
href="clean/2015-01-31-collatz-type_conjectures_continued.html">Collatz-type
Conjectures (Continued)</a></p>
<p>[<strong>2015-01-30</strong>] <a
href="clean/2015-01-30-collatz-type_conjectures.html">Collatz-type
Conjectures</a></p>
<p>[<strong>2015-01-28</strong>] <a
href="clean/2015-01-28-experiments_with_infinite_recursive_sequences_continued.html">Experiments
with Infinite Recursive Sequences (continued)</a></p>
<p>[<strong>2015-01-17</strong>] <a
href="clean/2015-01-17-experiments_with_infinite_recursive_sequences.html">Experiments
with Infinite Recursive Sequences</a></p>
<p>[<strong>2015-01-10</strong>] <a
href="clean/2015-01-10-goldbach_pairs.html">Goldbach Pairs</a></p>
<p>[<strong>2015-01-02</strong>] <a
href="clean/2015-01-02-collatz_lengths_continued.html">Collatz Lengths
(Continued)</a></p>
<p>[<strong>2015-01-01</strong>] <a
href="clean/2015-01-01-functional_streams.html">Functional
Streams</a></p>
<p>[<strong>2014-12-27</strong>] <a
href="clean/2014-12-27-polarization_in_the_us_congress.html">Polarization
in the US Congress</a></p>
<p>[<strong>2014-12-18</strong>] <a
href="clean/2014-12-18-partition_a_sequence.html">Partition a
sequence</a></p>
<p>[<strong>2014-11-28</strong>] <a
href="clean/2014-11-28-uniformly_random_permutations.html">Uniformly
Random Permutations</a></p>
<p>[<strong>2014-11-22</strong>] <a
href="clean/2014-11-22-an_implementation_of_ford-fulkerson_algorithm_in_common_lisp.html">An
Implementation of Ford-Fulkerson Algorithm in Common Lisp</a></p>
<p>[<strong>2014-11-17</strong>] <a
href="clean/2014-11-17-tropic_calculation_of_cheapest_paths.html">Tropic
Calculation of Cheapest Paths</a></p>
<p>[<strong>2014-11-05</strong>] <a
href="clean/2014-11-05-longest_common_subsequence_of_two_sequences.html">Longest
common subsequence of two sequences</a></p>
<p>[<strong>2014-10-30</strong>] <a
href="clean/2014-10-30-counting_spanning_trees_of_a_graph.html">Counting
Spanning Trees of a Graph</a></p>
<p>[<strong>2014-10-26</strong>] <a
href="clean/2014-10-26-longest_increasing_subsequence.html">Longest
Increasing Subsequence</a></p>
<p>[<strong>2014-10-24</strong>] <a
href="clean/2014-10-24-the_number_of_inversions_in_a_sequence.html">The
Number of Inversions in a Sequence</a></p>
<p>[<strong>2014-10-22</strong>] <a
href="clean/2014-10-22-hashes_and_entropy.html">Hashes and
Entropy</a></p>
<p>[<strong>2014-10-09</strong>] <a
href="clean/2014-10-09-estimating_cardinality_with_constant_memory_complexity.html">Estimating
Cardinality with Constant Memory Complexity</a></p>
<p>[<strong>2014-09-30</strong>] <a
href="clean/2014-09-30-landaus_function.html">Landau's Function</a></p>
<p>[<strong>2014-09-29</strong>] <a
href="clean/2014-09-29-a_problem_on_substitution_ciphers_and_group_theory.html">A
Problem on Substitution Ciphers and Group Theory</a></p>
<p>[<strong>2014-09-28</strong>] <a
href="clean/2014-09-28-a_morse_code_translator.html">A Morse Code
Translator</a></p>
<p>[<strong>2014-09-23</strong>] <a
href="clean/2014-09-23-a_memoization_macro_for_common_lisp.html">A
Memoization Macro for Common Lisp</a></p>
<p>[<strong>2014-09-21</strong>] <a
href="clean/2014-09-21-reducers_are_monoid_morphisms.html">Reducers are
Monoid Morphisms</a></p>
<p>[<strong>2014-09-18</strong>] <a
href="clean/2014-09-18-number_of_isomorphism_classes_of_binary_trees.html">Number
of isomorphism classes of binary trees</a></p>
<p>[<strong>2014-09-07</strong>] <a
href="clean/2014-09-07-cons_is_your_friend.html">CONS is your
friend</a></p>
<p>[<strong>2014-08-22</strong>] <a
href="clean/2014-08-22-a_zipfs_law_simulation.html">A Zipf's Law
Simulation</a></p>
<p>[<strong>2014-08-07</strong>] <a
href="clean/2014-08-07-generating_uniformly_random_trees.html">Generating
Uniformly Random Trees</a></p>
<p>[<strong>2014-07-09</strong>] <a
href="clean/2014-07-09-a_solution_for_project_euler_463.html">A Solution
for Project Euler #463</a></p>
<p>[<strong>2014-06-12</strong>] <a
href="clean/2014-06-12-entropy_of_truncated_md5_hashing.html">Entropy of
truncated MD5 hashing</a></p>
<p>[<strong>2014-06-08</strong>] <a
href="clean/2014-06-08-hexadecimal_digits_of_pi.html">Hexadecimal digits
of <span class="math inline"><em>π</em></span></a></p>
<p>[<strong>2014-02-11</strong>] <a
href="clean/2014-02-11-information_content_of_n-grams.html">Information
content of n-grams</a></p>
<p>[<strong>2014-02-08</strong>] <a
href="clean/2014-02-08-turkish_sentiment_analysis_using_thesaurus_distance.html">Turkish
Sentiment Analysis Using Thesaurus Distance</a></p>
<p>[<strong>2014-02-01</strong>] <a
href="clean/2014-02-01-sentiment_analysis_using_word_distances.html">Sentiment
analysis using word distances</a></p>
<p>[<strong>2014-01-27</strong>] <a
href="clean/2014-01-27-phase_transitions_in_entropy.html">Phase
transitions in entropy</a></p>
<p>[<strong>2013-12-13</strong>] <a
href="clean/2013-12-13-optimal_length_of_n-grams.html">Optimal length of
n-grams</a></p>
<p>[<strong>2013-12-10</strong>] <a
href="clean/2013-12-10-counting_strings_that_contain_intervals_of_same_letter_repetitions.html">Counting
strings that contain intervals of same letter repetitions</a></p>
<p>[<strong>2013-12-02</strong>] <a
href="clean/2013-12-02-patterns_separating_large_texts.html">Patterns
Separating Large Texts</a></p>
<p>[<strong>2013-11-23</strong>] <a
href="clean/2013-11-23-collatz_sequences_continued.html">Collatz
Sequences (Continued)</a></p>
<p>[<strong>2013-11-11</strong>] <a
href="clean/2013-11-11-entropy_and_approximately_one-to-one_maps.html">Entropy
and approximately one-to-one maps</a></p>
<p>[<strong>2013-10-23</strong>] <a
href="clean/2013-10-23-tree_isomorphism.html">Tree Isomorphism</a></p>
<p>[<strong>2013-10-15</strong>] <a
href="clean/2013-10-15-self_organizing_maps.html">Self Organizing
Maps</a></p>
<p>[<strong>2013-09-15</strong>] <a
href="clean/2013-09-15-euler_project_401.html">Euler Project
#401</a></p>
<p>[<strong>2013-09-15</strong>] <a
href="clean/2013-09-15-an_additively_recursive_definition_of_the_moebius_function.html">An
additively recursive definition of the Moebius function</a></p>
<p>[<strong>2013-09-11</strong>] <a
href="clean/2013-09-11-an_unsuccessful_attempt_for_solving_euler_project_401.html">An
Unsuccessful Attempt for Solving Euler Project #401</a></p>
<p>[<strong>2013-09-04</strong>] <a
href="clean/2013-09-04-uniform_sampling_from_parametrized_submanifolds_in_scala.html">Uniform
Sampling from Parametrized Submanifolds in Scala</a></p>
<p>[<strong>2013-09-04</strong>] <a
href="clean/2013-09-04-uniform_sampling_from_parametrized_submanifolds.html">Uniform
Sampling from Parametrized Submanifolds</a></p>
<p>[<strong>2013-08-30</strong>] <a
href="clean/2013-08-30-randomly_generated_points_obeying_a_distribution.html">Randomly
Generated Points Obeying a Distribution</a></p>
<p>[<strong>2013-08-25</strong>] <a
href="clean/2013-08-25-simulated_annealing_in_lisp.html">Simulated
Annealing in Lisp</a></p>
<p>[<strong>2013-08-21</strong>] <a
href="clean/2013-08-21-eigenvalues_and_eigenvectors_in_gsll.html">Eigenvalues
and Eigenvectors in GSLL</a></p>
<p>[<strong>2013-08-16</strong>] <a
href="clean/2013-08-16-reservoir_sampling.html">Reservoir
Sampling</a></p>
<p>[<strong>2013-08-11</strong>] <a
href="clean/2013-08-11-gibbs_sampling_in_lisp_compared_with_c.html">Gibbs
sampling in lisp compared with C</a></p>
<p>[<strong>2013-08-10</strong>] <a
href="clean/2013-08-10-logistic_regression_in_lisp.html">Logistic
Regression in lisp</a></p>
<p>[<strong>2013-08-10</strong>] <a
href="clean/2013-08-10-linear_discriminant_analysis_in_r.html">Linear
Discriminant Analysis in R</a></p>
<p>[<strong>2013-07-17</strong>] <a
href="clean/2013-07-17-a_gradient_descent_implementation_in_lisp.html">A
Gradient Descent Implementation in Lisp</a></p>
<p>[<strong>2013-07-01</strong>] <a
href="clean/2013-07-01-k-nearest_neighbor_classification_algorithm_implemented_in_lisp.html">k-Nearest
Neighbor Classification Algorithm Implemented in Lisp</a></p>
<p>[<strong>2013-05-19</strong>] <a
href="clean/2013-05-19-newton-raphson_method.html">Newton-Raphson
Method</a></p>
<p>[<strong>2013-05-07</strong>] <a
href="clean/2013-05-07-levenshtein_distance.html">Levenshtein
Distance</a></p>
<p>[<strong>2013-04-15</strong>] <a
href="clean/2013-04-15-cut_points_in_a_graph.html">Cut points in a
graph</a></p>
<p>[<strong>2013-04-01</strong>] <a
href="clean/2013-04-01-experiments_on_collatz_lengths_continued.html">Experiments
on Collatz Lengths (Continued)</a></p>
<p>[<strong>2013-02-18</strong>] <a
href="clean/2013-02-18-the_sound_of_the_torsion_parts_of_homotopy_groups_of_spheres.html">The
sound of the torsion parts of homotopy groups of spheres</a></p>
<p>[<strong>2013-02-12</strong>] <a
href="clean/2013-02-12-monadic_units.html">Monadic Units</a></p>
<p>[<strong>2013-02-07</strong>] <a
href="clean/2013-02-07-distribution_of_collatz_lengths_continued.html">Distribution
of Collatz Lengths (continued)</a></p>
<p>[<strong>2013-02-03</strong>] <a
href="clean/2013-02-03-distribution_of_collatz_lengths.html">Distribution
of Collatz Lengths</a></p>
<p>[<strong>2013-01-31</strong>] <a
href="clean/2013-01-31-quotients_of_polynomial_algebras.html">Quotients
of polynomial algebras</a></p>
<p>[<strong>2013-01-12</strong>] <a
href="clean/2013-01-12-path_ideals.html">Path ideals</a></p>
<p>[<strong>2013-01-10</strong>] <a
href="clean/2013-01-10-mccarthy91_terminates.html">McCarthy91
Terminates</a></p>
<p>[<strong>2013-01-09</strong>] <a
href="clean/2013-01-09-finding_all_paths_in_a_directed_graph.html">Finding
all paths in a directed graph</a></p>
<p>[<strong>2013-01-04</strong>] <a
href="clean/2013-01-04-a_simple_monte-carlo_integration_implementation_in_lisp.html">A
Simple Monte-Carlo Integration Implementation in Lisp</a></p>
<p>[<strong>2012-12-30</strong>] <a
href="clean/2012-12-30-a_simple_problem_in_kolmogorov-chaitin_complexity.html">A
simple problem in Kolmogorov-Chaitin complexity</a></p>
<p>[<strong>2012-12-29</strong>] <a
href="clean/2012-12-29-from_walks_to_paths.html">From walks to
paths</a></p>
<p>[<strong>2012-12-16</strong>] <a
href="clean/2012-12-16-higher_order_functions_functors_and_monads.html">Higher
order functions, functors and monads</a></p>
<p>[<strong>2012-12-13</strong>] <a
href="clean/2012-12-13-eccentricity_radius_and_diameter_in_an_undirected_graph.html">Eccentricity,
Radius and Diameter in an Undirected Graph</a></p>
<p>[<strong>2012-11-29</strong>] <a
href="clean/2012-11-29-untitled.html">Untitled</a></p>
<p>[<strong>2012-11-25</strong>] <a
href="clean/2012-11-25-strictly_increasing_labels_of_directed_graphs.html">Strictly
Increasing Labels of Directed Graphs</a></p>
<p>[<strong>2012-11-19</strong>] <a
href="clean/2012-11-19-strictly_increasing_labellings_of_directed_graphs.html">Strictly
Increasing Labellings of Directed Graphs</a></p>
<p>[<strong>2012-11-17</strong>] <a
href="clean/2012-11-17-nilpotent_elements_in_an_artinian_algebra.html">Nilpotent
elements in an artinian algebra</a></p>
<p>[<strong>2012-11-04</strong>] <a
href="clean/2012-11-04-local_rings_idempotents_and_non-invertible_elements.html">Local
rings, idempotents and non-invertible elements</a></p>
<p>[<strong>2012-10-18</strong>] <a
href="clean/2012-10-18-an_implementation_of_the_fixed-radius_near_neighbor_clustering_algorithm_in_lisp.html">An
implementation of the fixed-radius near neighbor clustering algorithm in
lisp</a></p>
<p>[<strong>2012-10-15</strong>] <a
href="clean/2012-10-15-reducing_directed_graphs.html">Reducing directed
graphs</a></p>
<p>[<strong>2012-10-10</strong>] <a href="clean/2012-10-10-an.html">An
implementation of the <span class="math inline"><em>k</em></span>-means
clustering algorithm in lisp</a></p>
<p>[<strong>2012-10-08</strong>] <a
href="clean/2012-10-08-a_comparison_of_different_map_functions_in_lisp.html">A
comparison of different map functions in lisp</a></p>
<p>[<strong>2012-10-03</strong>] <a
href="clean/2012-10-03-source_code_entropy.html">Source code
entropy</a></p>
<p>[<strong>2012-09-28</strong>] <a
href="clean/2012-09-28-collisions_in_random_walks.html">Collisions in
random walks</a></p>
<p>[<strong>2012-09-26</strong>] <a
href="clean/2012-09-26-transitive_closure_of_a_directed_graph.html">Transitive
closure of a directed graph</a></p>
<p>[<strong>2012-09-26</strong>] <a
href="clean/2012-09-26-solving_linear_equations_in_\mathbb_n.html">Solving
linear equations in <span class="math inline">ℕ</span></a></p>
<p>[<strong>2012-09-26</strong>] <a
href="clean/2012-09-26-listing_partitions.html">Listing
partitions</a></p>
<p>[<strong>2012-09-26</strong>] <a
href="clean/2012-09-26-inverting_formal_power_series.html">Inverting
formal power series</a></p>
<p>[<strong>2012-09-26</strong>] <a
href="clean/2012-09-26-hasse_subgraph_of_a_directed_graph.html">Hasse
subgraph of a directed graph</a></p>
</navigate>
<script type="text/javascript">
var sc_project=11685475; 
var sc_invisible=1; 
var sc_security="35211dd9"; 
</script>
<script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
</body>
</html>

